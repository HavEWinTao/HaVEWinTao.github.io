[{"title":"2343.裁剪数字后查询第K小的数字","url":"/2022/07/18/LeetCode刷题/2343.裁剪数字后查询第K小的数字/","content":"\n# \n\n## 题目描述\n\n一个下标从0开始的字符串数组nums，其中每个字符串长度相等且只包含数字\n\n一个下标从0开始的二维整数数组queries，其中$queries[i]=[k_i,trim_i]$。对于每个queries[i]，需要：\n\n    将nums中每个数字裁剪到剩下最右边$trim_i$个数位\n\n    在裁剪过后的数字中，找到nums中第$k_i$小数字对应的下标。如果两个裁剪后数字一样大，那么下标更小的数字视为更小的数字\n\n    将nums中每个数字恢复到原本字符串\n\n返回一个长度与queries相等的数组answer，其中answer[i]是第i次查询的结果\n\n提示：\n\n    裁剪到剩下x个数位的意思是不断删除最左边的数位，直到剩下x个数位\n\n    nums中的字符串可能会有前导0\n\n## 解题思路\n\n周赛题\n\n看了别人的代码自己写的还是复杂了点，但也仅仅点点吧，感觉还好（时间差不多\n\n```java\nList<String[]> temp = new ArrayList<>(n);\nfor (int j = 0; j < n; j++) {\n    String num = nums[j];\n    num = num.substring(m - trim);\n    temp.add(new String[]{num, String.valueOf(j)});\n}\ntemp.sort(((o1, o2) -> {\n    if (!Objects.equals(o1[0], o2[0])) {\n        return o1[0].compareTo(o2[0]);\n    } else {\n        Integer a = Integer.parseInt(o1[1]);\n        Integer b = Integer.parseInt(o2[1]);\n        return a.compareTo(b);\n    }\n}));\nans[i] = Integer.parseInt(temp.get(query[0] - 1)[1]);\n```\n\n将原先的每个数截取完trim后保存起来，同时保存他的索引\n\n重写sort，按数的大小和索引的大小进行排序\n\n最后保存所需要的索引\n","categories":["LeetCode刷题"]},{"title":"745.前缀和后缀搜索","url":"/2022/07/18/LeetCode刷题/745.前缀和后缀搜索/","content":"\n# 745.前缀和后缀搜索\n\n## 题目描述\n\n设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词\n\n实现WordFilter类：\n\nWordFilter(string[] words)使用词典中的单词words初始化对象\n\nf(string pref, string suff)返回词典中具有前缀prefix和后缀suff的单词的下标。如果存在不止一个满足要求的下标，返回其中最大的下标。如果不存在这样的单词，返回-1\n\n## 解题思路\n\n构建字典树\n\n```java\nclass Trie {\n    Map<Character, Trie> children;\n\n    List<Integer> index;\n\n    public Trie() {\n        children = new HashMap<>();\n        index = new ArrayList<>();\n    }\n}\n```\n\n字典树中每个节点保存index信息，表示第几个单词会走这条路径\n\n构建顺序字典树和逆序字典树\n\n查找单词时根据前缀树和后缀树找到两个list，表示都哪些单词会走这个路径\n\n然后取两个list中都包含的最大值，如果不存在就返回-1\n\n因为list的插入顺序是从小到大的，所以使用双指针直接O(n)就可以查找到\n","categories":["LeetCode刷题"]},{"title":"735.行星碰撞","url":"/2022/07/18/LeetCode刷题/735.行星碰撞/","content":"\n# 735.行星碰撞\n\n## 题目描述\n\n给定一个整数数组asteroids，表示在同一行的行星\n\n对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动\n\n找出碰撞后剩下的所有行星\n\n碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞\n\n## 解题思路\n\n循环直到某一轮没有行星发生碰撞\n\n从左到右遍历，如果i向右，i+1向左则会发生碰撞\n\n最后返回int[]\n\n```a.stream().mapToInt(Integer::intValue).toArray();```\n","categories":["LeetCode刷题"]},{"title":"565.数组嵌套","url":"/2022/07/18/LeetCode刷题/565.数组嵌套/","content":"\n# 565.数组嵌套\n\n## 题目描述\n\n索引从0开始长度为N的数组A，包含0到N-1的所有整数。找到最大的集合S并返回其大小，其中S[i]={A[i],A[A[i]],A[A[A[i]]],... }且遵守以下的规则\n\n假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]...以此类推，不断添加直到S出现重复的元素\n\n## 解题思路\n\n数组A满足：\n    A中不含有重复的元素\n\n    A中的元素大小在[0, N-1]之间\n\n这个题相当于给A中的数分组，在离散数学里学过一个叫啥着（置换群）\n\n```java\npublic int arrayNesting(int[] nums) {\n    int ans = 1;\n    int n = nums.length;\n    boolean[] visit = new boolean[n];\n    for (int i = 0; i < n; i++) {\n        if (visit[i]) {\n            continue;\n        }\n        Set<Integer> set = new HashSet<>();\n        int num = nums[i];\n        while (!set.contains(num)) {\n            set.add(num);\n            visit[num] = true;\n            num = nums[num];\n        }\n        ans = Math.max(ans, set.size());\n    }\n    return ans;\n}\n```\n\n","categories":["LeetCode刷题"]},{"title":"558.四叉树交集","url":"/2022/07/18/LeetCode刷题/558.四叉树交集/","content":"\n# 558.四叉树交集\n\n## 题目描述\n\n二进制矩阵中的所有元素不是0就是1\n\n两个四叉树，quadTree1和quadTree2。其中quadTree1表示一个$n\\times n$二进制矩阵，而quadTree2表示另一个$n\\times n$二进制矩阵\n\n返回一个表示$n\\times n$二进制矩阵的四叉树，它是quadTree1和quadTree2所表示的两个二进制矩阵进行按位逻辑或运算的结果\n\n当isLeaf为False时，你可以把True或者False赋值给节点，两种值都会被判题机制接受\n\n四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：\n\n    val：储存叶子结点所代表的区域的值。1对应True，0对应False\n    \n    isLeaf: 当这个节点是一个叶子结点时为True，如果它有4个子节点则为False\n\n## 解题思路\n\n题目描述的二进制矩阵与四叉树并不是一一对应的关系\n\n四叉树交集——二进制做或操作\n\n递归，解释见注释\n\n```java\npublic Node intersect(Node quadTree1, Node quadTree2) {\n    //如果tree1是叶子结点，如果他的值是true就返回true（因为是做或操作）\n    if (quadTree1.isLeaf) {\n        if (quadTree1.val) {\n            return new Node(true, true);\n        }\n        //因为tree1是fasle所以返回tree2\n        return quadTree2;\n    }\n    //互换位置\n    if (quadTree2.isLeaf) {\n        return intersect(quadTree2, quadTree1);\n    }\n    Node o1 = intersect(quadTree1.topLeft, quadTree2.topLeft);\n    Node o2 = intersect(quadTree1.topRight, quadTree2.topRight);\n    Node o3 = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n    Node o4 = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n    //都是叶子结点并且val相同需要合并\n    if (o1.isLeaf && o2.isLeaf && o3.isLeaf && o4.isLeaf && o1.val == o2.val && o1.val == o3.val && o1.val == o4.val) {\n        return new Node(o1.val, true);\n    }\n    //不是叶子结点，给四个区域赋值\n    return new Node(false, false, o1, o2, o3, o4);\n}\n```","categories":["LeetCode刷题"]},{"title":"2337.移动片段得到字符串","url":"/2022/07/11/LeetCode刷题/2337.移动片段得到字符串/","content":"\n# 2337.移动片段得到字符串\n\n## 题目描述\n\n两个字符串start和target，长度均为n。每个字符串仅由字符'L'、'R'和'_'组成，其中：\n\n    字符'L'和'R'表示片段，其中片段'L'只有在其左侧直接存在一个空位时才能向左 移动，而片段'R'只有在其右侧直接存在一个空位时才能向右移动\n\n    字符'_'表示可以被任意'L'或'R'片段占据的空位\n\n    如果在移动字符串start中的片段任意次之后可以得到字符串target，返回true；否则，返回false\n\n## 解题思路\n\n周赛题，最开始思路太乱了\n\n对i从0~length做循环，i表示前i个字符已经一样了\n\n如果start[i]和target[i]一样就看下一个字符\n\n不一样的话根据target的字符情况，L、R、_进行讨论\n\n如果是L，start只能从i的右侧来移动L过来\n\n如果是R，因为左侧字符已经都一样了，直接返回false\n\n如果是_，就只能将start的R右移才能出现_\n\n```java\npublic boolean canChange(String start, String target) {\n    int n = start.length();\n    start1 = start.toCharArray();\n    target1 = target.toCharArray();\n    for (int i = 0; i < n; i++) {\n        if (start1[i] == target1[i]) {\n            continue;\n        }\n        char c = target1[i];\n        if (c == 'L') {\n            int index = i;\n            while (index < n && start1[index] == '_') {\n                index++;\n            }\n            if (index == n) {\n                return false;\n            }\n            if (start1[index] == 'R') {\n                return false;\n            } else {\n                swap(index, i);\n            }\n        }\n        if (c == 'R') {\n            return false;\n        }\n        if (c == '_') {\n            int index = i;\n            while (index < n && start1[index] == 'R') {\n                index++;\n            }\n            if (index == n) {\n                return false;\n            }\n            if (start1[index] == '_') {\n                swap(i, index);\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```","categories":["LeetCode刷题"]},{"title":"2336.无限集中的最小数字","url":"/2022/07/11/LeetCode刷题/2336.无限集中的最小数字/","content":"\n# 2336.无限集中的最小数字\n\n## 题目描述\n\n现有一个包含所有正整数的集合[1, 2, 3, 4, 5, ...]\n\n实现SmallestInfiniteSet类：\n\n    SmallestInfiniteSet()初始化SmallestInfiniteSet对象以包含所有正整数\n\n    int popSmallest()移除并返回该无限集中的最小整数\n\n    void addBack(int num)如果正整数num不存在于无限集中，则将一个num添加 到该无限集中\n\n## 解题思路\n\n用一个minExits表示原本集合中最小的数，初始化为1\n\n用一个treemap保存后插入的数\n\n根据情况分类\n\n如删除最小整数，找到集合中小于minExits的最大整数，如果存在就删除set中的数，如果不存在就说明set中的数都大于minExits，就删除minExits\n\n```java\npublic int popSmallest() {\n    int ret;\n    if (set.isEmpty()) {\n        ret = minExits++;\n    } else {\n        Integer temp = set.floor(minExits);\n        if (temp != null) {\n            ret = set.pollFirst();\n        } else {\n            ret = minExits++;\n        }\n    }\n    return ret;\n}\n```\n\n如果插入的数大于minExits就已经存在不用管\n\n如果小于minExits，就放到set中（set会自动去重\n\n```java\npublic void addBack(int num) {\n    if (num < minExits) {\n        set.add(num);\n    }\n}\n```","categories":["LeetCode刷题"]},{"title":"2335.装满杯子需要的最短总时长","url":"/2022/07/11/LeetCode刷题/2335.装满杯子需要的最短总时长/","content":"\n# 2335.装满杯子需要的最短总时长\n\n## 题目描述\n\n现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满2杯不同类型的水或者1杯任意类型的水\n\n一个整数数组amount，其中amount[0]、amount[1]和amount[2]分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的最少秒数\n\n## 解题思路\n\n简单题，但是感觉挺有意思\n\n先排序，不能直接一步做完,因为哪个水需要的多或少是动态变化的\n\n```java\npublic int fillCups(int[] amount) {\n    Arrays.sort(amount);\n    int a = amount[0];\n    int b = amount[1];\n    int c = amount[2];\n    int ans = 0;\n    while (a != 0) {\n        a--;\n        ans++;\n        if (c > b) {\n            c--;\n        } else {\n            b--;\n        }\n    }\n    if (c > b) {\n        ans += c;\n    } else {\n        ans += b;\n    }\n    return ans;\n}\n```","categories":["LeetCode刷题"]},{"title":"676.实现一个魔法字典","url":"/2022/07/11/LeetCode刷题/676.实现一个魔法字典/","content":"\n# 676.实现一个魔法字典\n\n## 题目描述\n\n设计一个使用单词列表进行初始化的数据结构，单词列表中的单词互不相同。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。\n\n实现 MagicDictionary 类：\n\n    MagicDictionary()初始化对象\n\n    void buildDict(String[] dictionary) 使用字符串数组dictionary设定该数据结构，dictionary中的字符串互不相同\n\n    bool search(String searchWord)给定一个字符串searchWord，判定能否只将字符串中 一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回true；否则，返回false\n\n## 解题思路\n\n用一个map<int,set<string\\>\\>来保存这个长度的字符串\n\n然后search时遍历该长度的set中的所有单词，如果只有一个字母不同则返回true，如果有两个不同了就继续找下一个单词，如果遍历完了set还没找到单词就返回false\n","categories":["LeetCode刷题"]},{"title":"741.摘樱桃","url":"/2022/07/11/LeetCode刷题/741.摘樱桃/","content":"\n# 741.摘樱桃\n\n## 题目描述\n\n一个$N\\times N$的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：\n\n    0表示这个格子是空的，所以你可以穿过它\n\n    1表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它\n\n    -1表示这个格子里有荆棘，挡着你的路\n\n你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：\n\n从位置(0,0)出发，最后到达(N-1,N-1)，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）\n\n当到达(N-1,N-1)后，你要继续走，直到返回到(0,0)，只能向上或向左走，并且只能穿越有效的格子\n\n当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）\n\n如果在(0,0)和(N-1,N-1)之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到\n\n## 解题思路\n\n一个人从(0,0)走到(n-1,n-1),再从(n-1,n-1)走到(0,0)，相当于两个人同时从(0,0)走到(n-1,n-1)，每个人都可以向右或者向下\n\n设两个人的坐标为A(x1,y1),B(x2,y2),则状态可表示为dp[x1][x2][y1][y2]，表示当前状态下的最大樱桃数量\n\n若当前走了k次（k的取值范围是[0,2n-1),即从(0,0)走到(n-1,n-1)需要走2n-1步），则有x1+y1 = x2+y2 = k，所以y1、y2都和k有关系，则上述状态可简化为dp[x1][x2][k]\n\n为了方便，让A永远在B上方走，即x1<=x2\n\n分四种情况，A向下向右*B向下向右\n\n同时应该判断下如果AB在同一个位置则只算他们摘到了一个樱桃\n","categories":["LeetCode刷题"]},{"title":"648.单词替换","url":"/2022/07/11/LeetCode刷题/648.单词替换/","content":"\n# 648.单词替换\n\n## 题目描述\n\n在英语中可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为继承词\n\n例如，词根an，跟随着单词other(其他)，可以形成新的单词another(另一个)\n\n给定一个由许多词根组成的词典dictionary和一个用空格分隔单词形成的句子sentence。将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它\n\n输出替换之后的句子\n\n## 解题思路\n\n用一个set先将所有的词根保存起来\n\n将sentcen拆分成单词\n\n取单词的所有词根，$0-i(0\\le i\\lt length)$\n\n将每一个词根和set判断词根是否在set中，如果是就替换然后进行下一个单词\n","categories":["LeetCode刷题"]},{"title":"2327.知道秘密的人数","url":"/2022/07/05/LeetCode刷题/2327.知道秘密的人数/","content":"\n# 2327.知道秘密的人数\n\n## 题目描述\n\n在第1天，有一个人发现了一个秘密\n\n一个整数delay，表示每个人会在发现秘密后的delay天之后，每天给一个新的人分享秘密\n\n一个整数forget，表示每个人在发现秘密forget天之后会忘记这个秘密。一个人不能 在忘记秘密那一天及之后的日子里分享秘密\n\n一个整数n，返回在第n天结束时，知道秘密的人数\n\n由于答案可能会很大，将结果对$10^9+7$取余后返回\n\n## 解题思路\n\n统计第i天新增的人数，然后知道秘密的总人数其实就等于从最后一天往前推forget天的人数和\n\n每一个第i天知道秘密的人，都对[i+delay,i+forget)这个区间有贡献，从前往后推即可,时间复杂度O(n^2)\n\n（不知道我为啥陷入类似于斐波那契数列那种题的思路上去了\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"2326.螺旋矩阵IV","url":"/2022/07/05/LeetCode刷题/2326.螺旋矩阵IV/","content":"\n# 2326.螺旋矩阵IV\n\n## 题目描述\n\n两个整数：m和n，表示矩阵的维数\n\n一个整数链表的头节点head\n\n生成一个大小为mxn的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵左上角开始、顺时针按螺旋顺序填充\n\n如果还存在剩余的空格，则用-1填充\n\n返回生成的矩阵\n\n## 解题思路\n\n模拟\n\n行进方向有四种，向右->向下->向左->向上\n\n每次到达边界时边界都会产生相应的变化，如向右到达边界时上边界会发生变化\n\n每走一格让head=head->next直到head为null，填充的值由val变成-1\n\n(看别人代码怎么这么简洁,捂脸.jpg\n\n将四个方向坐标的变化保存起来，然后四个方向不断循环\n\n","tags":["模拟"],"categories":["LeetCode刷题"]},{"title":"871.最低加油次数","url":"/2022/07/05/LeetCode刷题/871.最低加油次数/","content":"\n# 871.最低加油次数\n\n## 题目描述\n\n汽车从起点出发驶向目的地，该目的地位于出发位置东面target英里处\n\n沿途有加油站，每个station[i]代表一个加油站，它位于出发位置东面station[i][0]英里处，并且有station[i][1]升汽油\n\n假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶1英里就会用掉1升汽油\n\n当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中\n\n为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1\n\n如果汽车到达加油站时剩余燃料为0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为0，仍然认为它已经到达目的地\n\n## 解题思路\n\ndp[i]表示加油i次的最大行驶英里数\n\n```java\nint n = stations.length;\nlong[] dp = new long[n + 1];\ndp[0] = startFuel;\nfor (int i = 0; i < n; i++) {\n    for (int j = i; j >= 0; j--) {\n        if (dp[j] >= stations[i][0]) {\n            dp[j + 1] = Math.max(dp[j + 1], dp[j] + stations[i][1]);\n        }\n    }\n}\nfor (int i = 0; i <= n; i++) {\n    if (dp[i] >= target) {\n        return i;\n    }\n}\nreturn -1;\n```\n\n加油站的位置已经是排好序的了，对每个加油站进行遍历\n\n当走到加油站i时，他已经加了最多i次油，对加油的次数进行遍历i~0\n\n如果加了j次油可以到达加油站i，那么就可以在这个加油站加油\n\n遍历完成后，遍历dp找到第一个能够达到目的地的次数，就是最小加油次数\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"556.下一个更大元素III","url":"/2022/07/05/LeetCode刷题/556.下一个更大元素III/","content":"\n# 556.下一个更大元素III\n\n## 题目描述\n\n一个正整数n，请你找出符合条件的最小整数，其由重新排列n中存在的每位数字组成，并且其值大于n。如果不存在这样的正整数，则返回-1\n\n返回的整数应当是一个32位整数，如果存在满足题意的答案，但不是32位整数，同样返回-1\n\n## 解题思路\n\n[31.下一个排列](/2021/11/07/LeetCode刷题/31.下一个排列/index.html)\n\n先把数的每一位提取出来，转换成char[]\n\n尽可能在靠右的低位进行交换\n\n从右往左找到第一个不满足从右往左是递增的位置，这个位置的数记为num1\n\n再从右往左找到第一个大于num1的数num2，下标为index\n\n将这两个数交换\n\n然后将index+1到末尾的这个区间内的数reverse，就是最小的\n\n同时本题需要判断是否在int范围内，将char[]用long型累加，然后和Integer.MAX_VALUE做比较\n","categories":["LeetCode刷题"]},{"title":"vs code-remote的使用","url":"/2022/07/01/其他/vs code-remote的使用/","content":"\n# vs code-remote的使用\n\n在vs code中下载vs code remote插件\n\n```\nHost ubuntu-s1(主机名)\n    HostName 192.168.231.129(主机ip)\n    User fantastic(登录用户名)\n```\n\n## 免密登录\n\nssh-keygen -t rsa -C \"邮箱\"\n\n生成的文件为$USER\\.ssh\\id_rsa\n\n将这个文件传到虚拟机中\n\n进入到登录用户的.ssh文件夹中\n\n```sh\nmv id_rsa.pub /root/.ssh/\ncat id_rsa.pub >> authorized_keys\nsudo /etc/init.d/ssh restart\n```\n\n这样就可以免密登录了\n\n## 开启root用户\n\nsever版的ubuntu初始化时不能创建root用户\n\n```sh\nsudo passwd root(开启root用户)\nsudo vi /etc/ssh/sshd_config\n```\n\n更改下面的设置\n\n```\nPermitRootLogin yes\nPasswordAuthentication yes\n```","categories":["其他"]},{"title":"535.TinyURL的加密与解密","url":"/2022/07/01/LeetCode刷题/535.TinyURL的加密与解密/","content":"\n# 535.TinyURL的加密与解密\n\n## 题目描述\n\nTinyURL是一种URL简化服务，比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URLhttp://tinyurl.com/4e9iAk。请你设计一个类来加密与解密TinyURL\n\n加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL 可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL\n\n## 解题思路\n\n用两个map\n\n1. tinyurl到原始url的映射map1\n2. 原始url到tinyurl的映射map2\n\ndecode的话是查询map1就行了\n\nencode的话就是生成一个随机的url，然后保存到map1和map2中去\n","categories":["LeetCode刷题"]},{"title":"324.摆动排序II","url":"/2022/07/01/LeetCode刷题/324.摆动排序II/","content":"\n# 324.摆动排序II\n\n## 题目描述\n\n一个整数数组nums，将它重新排列成$nums[0]<nums[1]\\>nums[2]<nums[3]...$的顺序。\n\n可以假设所有输入数组都可以得到满足题目要求的结果。\n\n## 解题思路\n\n1. 找中位数\n\n2. 将数组分为小于x 等于x 大于x的三个部分\n\n\n这个摆动数组，下标从0开始，奇数位是比较大的，偶数位是比较小的\n\n因为奇数位是比较大的，可以从右往左放比较大的数，先统一放奇数位\n\n然后从左往右放较小的数，放到偶数位上，这样比较小\n\n数组越靠左都是比中位数大的，这样放偶数位时候左面接近中位数，右面比较小\n\n因为奇数位左面大于中位数，右面接近中位数\n","categories":["LeetCode刷题"]},{"title":"241.为运算表达式设计优先级","url":"/2022/07/01/LeetCode刷题/241.为运算表达式设计优先级/","content":"\n# 241.为运算表达式设计优先级\n\n## 题目描述\n\n一个由数字和运算符组成的字符串expression，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。可以按任意顺序返回答案\n\n生成的测试用例满足其对应输出值符合32位整数范围，不同结果的数量不超过$10^4$\n\n$1 \\le expression.length \\le 20$\n\nexpression由数字和算符'+'、'-'和'*'组成\n\n输入表达式中的所有整数值在范围[0,99]\n\n## 解题思路\n\n我感觉这个题有hard难度了\n\n```java\npublic List<Integer> diffWaysToCompute(String expression) {\n        if (expression == null || expression.length() == 0) {\n            return new ArrayList<>();\n        }\n        char[] chars = expression.toCharArray();\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            char aChar = chars[i];\n            if (!Character.isDigit(aChar)) {\n                List<Integer> leftList = diffWaysToCompute(expression.substring(0, i));\n                List<Integer> rightList = diffWaysToCompute(expression.substring(i + 1));\n                for (Integer left : leftList) {\n                    for (Integer right : rightList) {\n                        if (aChar == '+') {\n                            ans.add(left + right);\n                        } else if (aChar == '-') {\n                            ans.add(left - right);\n                        } else {\n                            ans.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n        if (ans.isEmpty()) {\n            ans.add(Integer.valueOf(expression));\n        }\n        return ans;\n    }\n```\n\n使用递归的方法，如果expression是null或长度为0的话就返回空的list\n\n然后遍历整个字符串，碰到运算符就将两边分开，将两侧进行DFS\n\n最后的一步是将其转换成数字的，如果再dfs过程中expression中没有运算符，那么ans就为空，为空的话就表示她是一个数，然后将他转换成一个数，这样就可以向上传递，作为一个整数了，参与符号运算\n","tags":["DFS"],"categories":["LeetCode刷题"]},{"title":"OfferII.91.粉刷房子","url":"/2022/06/27/LeetCode刷题/OfferII.91.粉刷房子/","content":"\n# OfferII.91.粉刷房子\n\n## 题目描述\n\n假如有一排房子，共n个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同\n\n每个房子粉刷成不同颜色的花费是以一个$n\\times 3$的正整数矩阵costs来表示\n\n例如，costs[0][0]表示第0号房子粉刷成红色的成本花费；costs[1][2]表示第1号房子粉刷成绿色的花费，以此类推\n\n请计算出粉刷完所有房子最少的花费成本\n\n## 解题思路\n\n第i号房子和第i-1号房子的颜色必须不同，因此当第i号房子被粉刷成某一种颜色时，第i−1号房子只能被粉刷成另外两种颜色之一\n\n当第i号房子分别被粉刷成三种颜色时，粉刷第0号房子到第i号房子的最小花费成本计算如下：\n    \n    dp[i][0]=min(dp[i−1][1],dp[i−1][2])+costs[i][0]\n\n    dp[i][1]=min(dp[i−1][0],dp[i−1][2])+costs[i][1]\n\n    dp[i][2]=min(dp[i−1][0],dp[i−1][1])+costs[i][2]\n\n三种颜色的情况可以合并为一个状态转移方程，对于$1<=i\\lt n$和0<=j<3，状态转移方程如下：\n\n    dp[i][j]=min(dp[i−1][(j+1)mod3],dp[i−1][(j+2)mod3])+costs[i][j]\n\n计算结束时，dp[n−1]中的最小值即为粉刷所有房子的最小花费成本\n\n当i>=1时，由于dp[i]的计算只和dp[i−1]有关，因此可以使用滚动数组优化空间，将空间复杂度降低到O(1)","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"OfferII.29.排序的循环链表","url":"/2022/06/27/LeetCode刷题/OfferII.29.排序的循环链表/","content":"\n# OfferII.29.排序的循环链表\n\n## 题目描述\n\n给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素insertVal，使这个列表仍然是循环升序的\n\n给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针\n\n如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序\n\n如果列表为空（给定的节点是null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点\n\n## 解题思路\n\n对于只有一个结点或链表为空的情况\n\n```java\nif (head == null) {\n    insertNode.next = insertNode;\n    return insertNode;\n}\nif (head.next == head) {\n    head.next = insertNode;\n    insertNode.next = head;\n    return head;\n}\n```\n\n对于常规情况，应该找到结点插入的位置\n\n```java\nNode parent = head;\nNode cursor = head.next;\nwhile (cursor != head) {\n    if (insertVal >= parent.val && insertVal <= cursor.val) {\n        break;\n    }\n    if (parent.val > cursor.val) {\n        if (insertVal > parent.val || insertVal < cursor.val) {\n            break;\n        }\n    }\n    parent = parent.next;\n    cursor = cursor.next;\n}\n```\n\n插入的结点应该在parent后面，parent总是在cursor前一个，如果parent<=insert<=cursor,parent就是插入位置\n\n但是这是常规情况，如果insert比原链表的最大值大或比最小值小呢，找到链表的末尾(parent>cursor),然后做判断，可以得到插入位置\n","categories":["LeetCode刷题"]},{"title":"2311.小于等于K的最长二进制子序列","url":"/2022/06/27/LeetCode刷题/2311.小于等于K的最长二进制子序列/","content":"\n# 2311.小于等于K的最长二进制子序列\n\n## 题目描述\n\n一个二进制字符串s和一个正整数k\n\n返回s的最长子序列，且该子序列对应的二进制数字小于等于k\n\n注意：\n\n    子序列可以有前导0\n\n    空字符串视为0\n\n    子序列是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列\n\n## 解题思路\n\n这题过了，但是写麻烦了，只能说代码又臭又长，时间复杂度还高\n\n前面的0都可以保留，然后找到一个1的位置，判断以该位置为起始位置的子串能保留多少位($O(n^2)$)\n\n<hr>\n\n**只有1才对数的大小做贡献**\n\n为什么从后往前遍历呢？因为后位的1的贡献一定把比前位的1的贡献小，即使后位选上后导致前位不能选，也不会对结果产生影响\n\n    如：s=\"0111000\"，k是17，从后往前遍历，8选上了，这样的话16就不能选了，但是对答案没影响\n\n    再如：s=\"0011111\",k=17,从后往前遍历，1,2,4,8都选上了，这样的最后答案中1的位数比单选16和8要多\n\n从低位到高位遍历s（反向遍历s），记需要移除的1的个数为removed：\n\n若当前位为0，可保留；\n\n若当前位为1，分类判断：\n\n    计入当前位1，数字总和依然<=k，可保留；\n    计入当前位1，数字总和>k，不可保留，removed+1\n\n最终返回s的总长度减去需要删除的1的个数，即len(s)−removed\n","tags":["贪心"],"categories":["LeetCode刷题"]},{"title":"710.黑名单中的随机数","url":"/2022/06/27/LeetCode刷题/710.黑名单中的随机数/","content":"\n# 710.黑名单中的随机数\n\n## 题目描述\n\n给定一个整数n和一个无重复黑名单整数数组blacklist\n\n设计一种算法，从[0,n-1]范围内的任意整数中选取一个未加入黑名单blacklist的整数\n\n任何在上述范围内且不在黑名单blacklist中的整数都应该有同等的可能性被返回\n\n优化你的算法，使它最小化调用语言内置随机函数的次数\n\n实现Solution类:\n\n    Solution(int n, int[] blacklist)初始化整数n和被加入黑名单blacklist的整数\n\n    int pick()返回一个范围为[0,n-1]且不在黑名单blacklist中的随机整数\n\n## 解题思路\n\n一个整数n,一个黑名单，黑名单中所有数都小于n，并且黑名单中所有数都不相同\n\n假设黑名单中数字的个数为m，那么能够返回的数一共有n-m个\n\n因为要优化调用随机函数的次数，可以将所有的数映射到[0~n-m）的区间上，这样调用一次random就可以返回符合条件的随机数了\n\n用一个map，key是[0~n-m)，value是要对应的随机数\n\n构建map：\n\n    对于不在黑名单中的数，value=key\n\n    对于在黑名单中的数，如果该数大于n-m就可以忽略了，存到set中\n\n    如果该数小于n-m应该把这个数映射成[n-m,n)中不是黑名单的数，用set判断\n\n    因为黑名单数量m和n是确定的，一一映射后能够保持随机性\n\n```java\npublic int pick() {\n    int x = random.nextInt(bound);\n    return b2w.getOrDefault(x, x);\n}\n```","categories":["LeetCode刷题"]},{"title":"522.最长特殊序列II","url":"/2022/06/27/LeetCode刷题/522.最长特殊序列II/","content":"\n# 522.最长特殊序列II\n\n## 题目描述\n\n给定字符串列表strs，返回其中最长的特殊序列。如果最长特殊序列不存在，返回-1\n\n特殊序列定义如下：\n\n    该序列为某字符串独有的子序列（即不能是其他字符串的子序列）\n\ns的子序列可以通过删去字符串s中的某些字符实现\n\n## 解题思路\n\n对于字符串i来说，如果他不是所有其他字符串的子串，那么他就是一个特殊字符串\n\n对于strs中的所有字符串，走一遍遍历，就可以判断出最长的特殊序列\n\n怎么判断字符串s是不是字符串t的子串呢，如果s是t的子串，那么s中的所有字符都会在t中按顺序出现\n\n双指针，如果指向s中的字母和当前指向t的字母不相同，那t的指针后移，如果相同那么s和t都后移\n\n最后判断指向s的指针是否在s末尾了，如果再末尾了就证明是子串\n\n```java\n//判断s是否是t的子串\npublic boolean isSubseq(String s, String t) {\n    int ptS = 0, ptT = 0;\n    while (ptS < s.length() && ptT < t.length()) {\n        if (s.charAt(ptS) == t.charAt(ptT)) {\n            ++ptS;\n        }\n        ++ptT;\n    }\n    return ptS == s.length();\n}\n```\n","categories":["LeetCode刷题"]},{"title":"515.在每个树行中找最大值","url":"/2022/06/27/LeetCode刷题/515.在每个树行中找最大值/","content":"\n# 515.在每个树行中找最大值\n\n## 题目描述\n\n给定一棵二叉树的根节点root ，请找出该二叉树中每一层的最大值\n\n## 解题思路\n\nBFS，遍历每层的时候记录最大值，记录到ans中\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"513.找树左下角的值","url":"/2022/06/27/LeetCode刷题/513.找树左下角的值/","content":"\n# 513.找树左下角的值\n\n## 题目描述\n\n给定一个二叉树的根节点root，请找出该二叉树的最底层最左边节点的值\n\n假设二叉树中至少有一个节点\n\n## 解题思路\n\nBFS找到最后一层，遍历中queue中第一个元素就是该层最左边的结点\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"508.出现次数最多的子树元素和","url":"/2022/06/27/LeetCode刷题/508.出现次数最多的子树元素和/","content":"\n# 508.出现次数最多的子树元素和\n\n## 题目描述\n\n一个二叉树的根结点root，请返回出现次数最多的子树元素和\n\n如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）\n\n一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）\n\n## 解题思路\n\nDFS求和，并且将和以及它出现的次数保存起来，然后返回出现次数最多的和\n\n```java\nprivate int getSum(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    int sum = root.val + getSum(root.left) + getSum(root.right);\n    int cnt = cntSum.getOrDefault(sum, 0);\n    cntSum.put(sum, cnt + 1);\n    return sum;\n}\n```\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"30.串联所有单词的子串","url":"/2022/06/27/LeetCode刷题/30.串联所有单词的子串/","content":"\n# 30.串联所有单词的子串\n\n## 题目描述\n\n给定一个字符串s和一些长度相同的单词words\n\n找出s中恰好可以由words中所有单词串联形成的子串的起始位置\n\n注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。\n\n## 解题思路\n\nwords中可能是有重复单词的，所以用set不行，可以用map，key是words中的字符串，value是字符串出现的次数\n\n（如果考虑words中的顺序的话就得用list了，但本题不考虑）\n\n从字符串s的第一个字母开始遍历，判断（judge），如果返回true，就该起始位置加入到ans中\n\njudge：\n    \n    判断该index起始的子串能不能与words完全匹配\n","categories":["LeetCode刷题"]},{"title":"1089.复写零","url":"/2022/06/17/LeetCode刷题/1089.复写零/","content":"\n# 1089.复写零\n\n## 题目描述\n\n一个长度固定的整数数组arr，将该数组中出现的每个零都复写一遍，并将其余的元素向右平移\n\n注意：不要在超过该数组长度的位置写入元素\n\n要求：请对输入的数组**就地**进行上述修改，不要从函数返回任何东西\n\n## 解题思路\n\n难点在就地修改\n\n先遍历一遍，判断复写零后的数组占原数组中的几个数\n\n```java\nint n = arr.length;\nint index = 0;\nint i = -1;\nwhile (index < n) {\n    i++;\n    if (arr[i] == 0) {\n        index += 2;\n    } else {\n        index++;\n    }\n}\n```\n\ni就是原数组的下标\n\n然后需要对最后一个数(arr[i])进行判断,因为在新数组中可能是00也可能是0\n\n```java\nint right = n - 1;\nif (arr[i] == 0 && index == n) {\n    arr[right--] = 0;\n    arr[right--] = 0;\n    i--;\n} else {\n    arr[right--] = arr[i--];\n}\n```\n\n然后将i和right向前遍历得到复写0后的数组\n","categories":["LeetCode刷题"]},{"title":"1051.高度检查器","url":"/2022/06/17/LeetCode刷题/1051.高度检查器/","content":"\n# 1051.高度检查器\n\n## 题目描述\n\n学生需要按照非递减的高度顺序排成一行\n\n排序后的高度情况用整数数组expected表示，其中expected[i] 是预计排在这一行中第i位的学生的高度（下标从0开始）\n\n一个整数数组heights，表示当前学生站位的高度情况。heights[i]是这一行中第i位学生的高度（下标从0开始）\n\n返回满足 heights[i] != expected[i] 的 下标数量 。\n\n## 解题思路\n\n注意**1\\<=heights.length\\<=100**\n\n所以可以用桶排序\n\n先找到最高的，确定桶的数目，然后记录每个高度的学生的数量\n\n```java\nint index = 0;\nint ans = 0;\nfor (int i = 1; i <= max; i++) {\n    for (int j = 0; j < bucket[i]; j++) {\n        if (heights[index] != i) {\n            ans++;\n        }\n        index++;\n    }\n}\nreturn ans;\n```\n\n遍历得到ans\n","tags":["桶排序"],"categories":["LeetCode刷题"]},{"title":"890. 查找和替换模式","url":"/2022/06/17/LeetCode刷题/890. 查找和替换模式/","content":"\n# 890. 查找和替换模式\n\n## 题目描述\n\n有一个单词列表words和一个模式 pattern，想知道words中的哪些单词与模式匹配\n\n单词与模式的字母间形成双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母(映射的字母可以相同，如a--a)\n\n返回words中与给定模式匹配的单词列表\n\n可以按任何顺序返回答案\n\n## 解题思路\n\n用两个map记录这个双射\n\n当双射存在冲突时返回false\n\n如果双射构建成功返回true\n","categories":["LeetCode刷题"]},{"title":"719.找出第K小的数对距离","url":"/2022/06/17/LeetCode刷题/719.找出第K小的数对距离/","content":"\n# 719.找出第K小的数对距离\n\n## 题目描述\n\n数对(a,b)由整数a和b组成，其数对距离定义为a和b的绝对差值\n\n一个整数数组nums和一个整数k，数对由nums[i]和nums[j]组成且满足0\\<=i\\<j\\<nums.length\n\n返回所有数对距离中第k小的数对距离\n\n## 解题思路\n\n先排序，差值最大为nums[n-1]，最小为0(不确定，但肯定大于0),对这个差值进行二分\n\n找到小于这个差值的所有数对的个数(可以类似于[532.数组中的k-diff数对](/2022/06/17/LeetCode刷题/532.数组中的k-diff数对/index.html)来二分计算)\n\n最后可以确定个数正好为k的差值大小，就是ans\n","tags":["二分"],"categories":["LeetCode刷题"]},{"title":"532.数组中的k-diff数对","url":"/2022/06/17/LeetCode刷题/532.数组中的k-diff数对/","content":"\n# 532.数组中的k-diff数对\n\n## 题目描述\n\n一个整数数组nums和一个整数k，在数组中找出不同的k-diff数对，并返回不同的 k-diff数对的数目\n\nk-diff数对定义为一个整数对(nums[i], nums[j])，并满足下述全部条件：\n\n- 0 <= i, j < nums.length\n- i != j\n- nums[i] - nums[j] == k\n\n## 解题思路\n\n数组长度记为n,一个数组中共有数对n(n-1)，对数组进行排序并不影响数对的信息\n\n所以先对数对进行排序\n\n然后从第一个数开始nums[i],在nums[i+1,n-1]中查找k+nums[i]\n\n    因为已经排序,nums[j]>nums[i],(nums[j]-nums[i]=k)，所以应查找的数为k+nums[i]\n\n    因为已经排序，所以查找可以使用二分查找\n\n因为题目要求找出数组中不同的k-diff数对,所以应该跳过相同的nums[i]，从下一个不同的数继续查找\n\n记录ans并返回\n","tags":["二分"],"categories":["LeetCode刷题"]},{"title":"498.对角线遍历","url":"/2022/06/17/LeetCode刷题/498.对角线遍历/","content":"\n# 498.对角线遍历\n\n## 题目描述\n\n给你一个大小为$m\\times n$的矩阵mat，以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素\n\n{%asset_img 498.findDiagonalOrder.jpg 对角线遍历 %}\n\n## 解题思路\n\n从i,j都为0开始，直到i,j为m,n\n\n有右上斜线或左下斜线两种方向，用一个flag标记走的方向，完成对i和j的更改\n\n对于更改完的i,j坐标，可能存在超出边界的情况\n\n右上方向斜线有三种\n\n1. i\\<0，但是j在范围内\n2. i\\<0，j==n\n3. j==n，但是i在范围内\n\n左下方向斜线有三种\n\n1. j\\<0,但是i在范围内\n2. j\\<0,i==m\n3. i==m,打算j在范围内\n\n对着六种情况的坐标进行更改最后得到ans\n","categories":["LeetCode刷题"]},{"title":"497.非重叠矩形中的随机点","url":"/2022/06/11/LeetCode刷题/497.非重叠矩形中的随机点/","content":"\n# 497.非重叠矩形中的随机点\n\n## 题目描述\n\n给定一个由非重叠的轴对齐矩形的数组rects，其中$rects[i]=[a_i,b_i,x_i,y_i]$表示$(a_i,b_i)$是第i个矩形的左下角点，$(x_i,y_i)$是第i个矩形的右上角点\n\n设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。在给定的矩形覆盖的空间内的任何整数点都有可能被返回\n\n## 解题思路\n\n遍历rects记录每个正方形包含的点的个数，保存到数组中（递增），总点的个数记为sum\n\n生成0~sum的随机数random，通过二分查找找到生成的随机点应该位于哪个长方形中\n\n将random减去他前面的的点数的和，然后random就是在当前长方形的点，以左下角为基准点，除以每行的点数得到纵坐标便宜，对每行的点数取余就是横坐标的偏移\n\n将偏移量与基准点作为和就是返回的随机点\n","categories":["LeetCode刷题"]},{"title":"2294.划分数组使最大差为K","url":"/2022/06/07/LeetCode刷题/2294.划分数组使最大差为K/","content":"\n# 2294.划分数组使最大差为K\n\n## 题目描述\n\n一个整数数组nums和一个整数k。你可以将 nums划分成一个或多个子序列，使nums中的每个元素都恰好出现在一个子序列中。\n\n在满足每个子序列中最大值和最小值之间的差值最多为k的前提下，返回需要划分的最少子序列数目\n\n子序列本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到\n\n## 解题思路\n\n所有的子序列与原数组的顺序无关，子序列看做一个集合的话相对于原数组总是满足顺序条件的\n\n所以可以对原数组排序，然后一遍遍历判断满足**最大值和最小值之间的差值最多为k**条件的即可\n","categories":["LeetCode刷题"]},{"title":"给虚拟机固定IP","url":"/2022/06/07/其他/给虚拟机固定IP/","content":"\n# 给虚拟机固定IP\n\n用VMware的DHCP自动分配如果就启动一个虚拟机还好，启动多个ip会变，为了方便ssh连接，所以需要将ip固定住\n\n根本不需要调整windows下网络适配器VMnet8，VMware中设置好了VMnet8的子网\n\n需要先查看VMware Network Adapter VMnet8的ip\n\n在虚拟机中修改```/etc/netplan/```中的配置文件\n**network-manager-all**(也有可能叫00-install什么.yaml)\n\n```yaml\nnetwork:\n  ethernets:\n    ens33:     #配置的网卡的名称\n      addresses: [192.168.146.168/24] #静态ip地址和掩码\n      dhcp4: no #关闭DHCP\n      optional: true\n      gateway4: 192.168.146.2 #网关地址\n      nameservers:\n         addresses: [8.8.8.8,8.8.4.4]#DNS服务器地址\n  version: 2\n  renderer: networkd\n```\n\naddress直接给VMnet8的子网ip\n\n网关将VMnet8的子网设置为2就行了\n\n重启后就固定ip了\n\n## VMnet8的规则\n\n以本机的192.168.231.0网段为例：\n\n第一个地址(192.168.231.1):静态地址，分配给了宿主机的VMware Network Adapter VMnet8适配器使用。\n\n第二个地址(192.168.231.2):静态地址，分配给了NAT设备使用。\n\n(192.168.231.3到192.168.231.127)静态地址，保留。\n\n(192.168.231.128到192.168.231.254)：DHCP作用域地址范围，分配给虚拟机使用。\n\n最后一个地址(192.168.231.255)广播地址。\n\nVMware默认安装后的规则都是如此\n","categories":["其他"]},{"title":"875.爱吃香蕉的珂珂","url":"/2022/06/07/LeetCode刷题/875.爱吃香蕉的珂珂/","content":"\n# 875.爱吃香蕉的珂珂\n\n## 题目描述\n\n有n堆香蕉，第i堆中有piles[i]根香蕉。需要在h小时内吃完\n\n珂珂可以决定她吃香蕉的速度k（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉k根。如果这堆香蕉少于k根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉\n\n返回她可以在h小时内吃掉所有香蕉的最小速度k（k为整数）\n\n## 解题思路\n\n因为珂珂吃掉一堆的所有香蕉，一小时内不会再吃更多的香蕉，所以最小速度k的上限是$max(piles)$\n\n假如$k_0$满足条件，那么对于$k>k_0$，$k$一定满足条件，所以可以使用二分进行判断\n\n需要判断对于k行不行，遍历piles得到总时间和h来判断\n\n对于left=1和k=max(piles),如果mid=(left+k)/2可行，那么k=mid，如果不可行，那么left=mid+1\n","tags":["二分"],"categories":["LeetCode刷题"]},{"title":"478.在圆内随机生成点","url":"/2022/06/07/LeetCode刷题/478.在圆内随机生成点/","content":"\n# 478.在圆内随机生成点\n\n## 题目描述\n\n给定一个圆，在圆中产生均匀随机点\n\n## 解题思路\n\n假设：**语言提供的生成浮点数的API得到的结果是均匀的**\n\n正常直接取半径范围的随机数是不可行的，因为题目要求在园内产生均匀随机点\n\n1. 拒绝采样：\n    \n    按正方形来算，然后产生随机点，不在圆内就舍弃重新生成随机点，直到点在圆内\n\n2. 分布函数\n\n    取半径范围的随机数从一维上来看是均匀的，但是在圆中不均匀，圆的面积是$\\pi\\times r^2$\n    \n    从$(0,r^2)$内随机再开平方，从而确保距离与面积比例一致\n","categories":["LeetCode刷题"]},{"title":"829.连续整数求和","url":"/2022/06/03/LeetCode刷题/829.连续整数求和/","content":"\n# 829.连续整数求和\n\n## 题目描述\n\n给定一个正整数n，返回连续正整数满足所有数字之和为n的组数\n\n## 解题思路\n\n单独的一个数n也算做答案\n\n公差为1的等差数列求和，首项为a，共k项,和为n,其中n是已知的\n\n$$s_n = (a+a+k-1)/2*k=n$$\n\n$$2a+k-1 = 2n/k$$\n\n$$2a = 2n/k-k+1$$\n\n首先$2n/k$肯定得是个整数，同时$(2n/k-k+1)/2$也应该是个整数\n\n同时$$2n/k-k+1=2a\\geq 2$$\n\n$$2n/k-k\\geq 1$$\n\n$2n/k>k$,$k^2<2n$\n\n这样的话对k从1开始遍历，然后找到满足条件的即可ans++\n","tags":["数论"],"categories":["LeetCode刷题"]},{"title":"473.火柴拼正方形","url":"/2022/06/03/LeetCode刷题/473.火柴拼正方形/","content":"\n# 473.火柴拼正方形\n\n## 题目描述\n\n一个整数数组matchsticks，其中matchsticks[i]是第i个火柴棒的长度\n\n用所有的火柴棍拼成一个正方形。不能折断任何一根火柴棒，但可以把它们连在一起，而且每根火柴棒必须使用一次\n\n能使这个正方形，则返回true，否则返回false\n\n## 解题思路\n\n因为每个火柴都需要被使用，所以需要火柴长度和能被4整除\n\n将火柴分成4分，$DFS(O(4^n))$再加剪枝\n","categories":["LeetCode刷题"]},{"title":"450.删除二叉搜索树中的节点","url":"/2022/06/03/LeetCode刷题/450.删除二叉搜索树中的节点/","content":"\n# 450.删除二叉搜索树中的节点\n\n## 题目描述\n\n一个二叉搜索树，删除一个结点（可能有可能没有）\n\n返回删除结点后的树\n\n## 解题思路\n\n我原本想的是先找到这个结点，然后看右子树，如果没有右子树就可以直接删了，如果有右子树，右子树的最左结点的值替换删除结点的值，然后删除最左结点，但好像有点问题\n\n题解思路是一样的，不过是把最左节点的左子树等于删除结点的左子树\n\n右节点的最左结点肯定比删除结点大，可以顶替删除结点的位置啊我觉得","tags":["树"],"categories":["LeetCode刷题"]},{"title":"1021.删除最外层的括号","url":"/2022/05/29/LeetCode刷题/1021.删除最外层的括号/","content":"\n# 1021.删除最外层的括号\n\n## 题目描述\n\n一个字符串，它是由多个匹配的括号字符串构成的，要求删去每个匹配字符串的最外层的括号\n\n## 解题思路\n\n用一个栈记录每个匹配的，然后构造的时候匹配到最后一个时就可以取去其中间的内容了\n\n不断拼接，返回ans\n","categories":["LeetCode刷题"]},{"title":"699.掉落的方块","url":"/2022/05/29/LeetCode刷题/699.掉落的方块/","content":"\n# 699.掉落的方块\n\n## 題目描述\n\n在二维平面上的x轴上，放置着一些方块。\n\n给你一个二维整数数组positions，其中$positions[i]=[left_i,sideLength_i]$表示：第i个方块边长为$sideLength_i$，其左侧边与x轴上坐标点$left_i$对齐\n\n每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿y轴负方向下落，直到着陆到\n\n另一个正方形的顶边或者是x轴上。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。\n\n在每个方块掉落后，你必须记录目前所有已经落稳的方块堆叠的最高高度。\n\n返回一个整数数组ans，其中ans[i]表示在第i块方块掉落后堆叠的最高高度。\n\n{%asset_img 掉落的方块.jpg 掉落的方块 %}\n\n## 解题思路\n\n看了一眼数据量，直接将每个横坐标记录不太可行\n\n用map记录区间坐标和高度，这样就可以记得下了\n\nTreeMap会自动将key排序，本题用TreeMap即可\n\n落下时看落到哪，然后更新map，过程比较繁琐\n\n然后找到高度值构造ans","categories":["LeetCode刷题"]},{"title":"467.环绕字符串中唯一的子字符串","url":"/2022/05/25/LeetCode刷题/467.环绕字符串中唯一的子字符串/","content":"\n# 467.环绕字符串中唯一的子字符串\n\n## 题目描述\n\n把字符串s看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以s看起来是这样的：\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"\n \n现在给定另一个字符串p。返回s中唯一的p的非空子串的数量\n\n## 解题思路\n\n用dp，一个dp[i]可以表示是以26个英文字母中以第i个字母结尾的字符串，然后根据长度就可以唯一确定一个非空子串了\n\n遍历p，并且用k标记当前的长度\n\n如果第i个和第i-1个字母是递增的关系（环形），那就将k+1，并且当前字母的dp值取k和原dp值较大的那个\n\n如果不是递增的关系，将k置为1\n\n整个p遍历完成后就可以对dp求和得到答案了\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"675.为高尔夫比赛砍树","url":"/2022/05/25/LeetCode刷题/675.为高尔夫比赛砍树/","content":"\n# 675.为高尔夫比赛砍树\n\n## 题目描述\n\n树林由一个$m\\times n$的矩阵表示，在这个矩阵中\n\n    0表示障碍，无法触碰\n    \n    1表示地面，可以行走\n    \n    比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度\n\n每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。\n\n需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为1（即变为地面）\n\n从(0,0)点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回-1\n\n可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树\n\n## 解题思路\n\n首先所有的树高度都是不同的，题目要求从高到低砍树\n\n首先记录所有的树的高度和位置，然后按高度排序\n\n遍历每一棵树，从(0,0)到第一棵树的位置，再从第一棵树到第二颗树的位置，直到将所有的树都砍完\n\n如果有不能砍的树就返回-1\n\n需要完成的一个函数是找到两点间的最近距离，这个可以使用BFS，从起点不断的BFS，直到到终点，可行走的条件题中已经给出\n","categories":["LeetCode刷题"]},{"title":"961.在长度2N的数组中找出重复N次的元素","url":"/2022/05/22/LeetCode刷题/961.在长度 2N 的数组中找出重复 N 次的元素/","content":"\n# 961.在长度2N的数组中找出重复N次的元素\n\n## 题目描述\n\n给你一个整数数组 nums ，该数组具有以下属性：\n\nnums.length == 2 * n.\nnums 包含 n + 1 个 不同的 元素\nnums 中恰有一个元素重复 n 次\n找出并返回重复了 n 次的那个元素。\n\n## 解题思路\n\n因为2N个数字中有N个相同的，假设将N个数字全部隔开，中间需要N-1个数字，而还有一个数字，所以最长可以有中间隔了两个数字的相同数字\n\n这样的话判断nums[i]与nums[i+1],nums[i]与nums[i+2],nums[i]与nums[i+3]\n","categories":["LeetCode刷题"]},{"title":"436.寻找右区间","url":"/2022/05/22/LeetCode刷题/436.寻找右区间/","content":"\n# 436.寻找右区间\n\n## 题目描述\n\n一个区间数组intervals，其中$intervals[i]=[start_i,end_i]$，且每个$start_i$都不同\n\n区间i的右侧区间可以记作区间j，并满足$start_j >= end_i$，且$start_j$最小化\n\n返回一个由每个区间i的右侧区间在intervals中对应下标组成的数组。如果某个区间i不存在对应的右侧区间，则下标i处的值设为-1\n\n## 解题思路\n\n因为每个$start_i$都不同，将$strat_i$的值和索引保存起来，然后直接对intervals进行排序\n\n对于每个intervals中的元素，他的$end_i$,找到最小的$strat_j>=end_i$，使用二分查找，找到这个$start_j$时间复杂度就是O(nlogn)\n\n最开始时我直接查找不到直接返回-1，但是这样是不对的，因为有的数据内是有-1的\n\n所以find的返回值可以有两个，其中一个是标记是否找到了，另一个是找到的值\n","categories":["LeetCode刷题"]},{"title":"668.乘法表中第k小的数","url":"/2022/05/19/LeetCode刷题/668.乘法表中第k小的数/","content":"\n# 668.乘法表中第k小的数\n\n## 题目描述\n\n在乘法表中快速找到第k小的数字\n\n给定高度m、宽度n的一张m*n的乘法表，以及正整数k，你需要返回表中第k小的数字\n\n## 解题思路\n\n一个乘法表呢横着看是递增的，竖着看也是递增的，但是整体看就不行了\n\n一个乘法表里有m*n个数字范围是1~m*n，可能其中有些数字不存在，也有相同的数字\n\n想找到第k小的数字，这个数字可能是1~m*n个数字中的第mid个，进行二分\n\n定义一个函数，getCnt(int mid)找到整个乘法表中小于等于mid的数的个数\n\n对mid进行二分\n\n    如果getCnt的返回值大于等于k，就说明应该继续找mid左面的部分\n\n    如果getCnt的返回值小于k，就说明应该找mid的右面的部分\n\n    当l\\<r时就一直遍历，不然就跳出了\n\n返回r即可\n","categories":["LeetCode刷题"]},{"title":"462.最少移动次数使数组元素相等II","url":"/2022/05/19/LeetCode刷题/462.最少移动次数使数组元素相等II/","content":"\n# 462.最少移动次数使数组元素相等II\n\n## 题目描述\n\n一个长度为n的整数数组nums，返回使所有数组元素相等需要的最少移动数\n\n在一步操作中，你可以使数组中的一个元素加1或者减1。\n\n## 解题思路\n\n想到了先排序，拿中间的数来遍历做差来算ans\n\n最开始想到了将nums分为奇数和偶数，然后偶数的话就得取两个中位数，对两个中位数都做判断\n\n后来发现其实对于偶数取两个中位数是没有必要的\n\n$[x_1,x_2,...,a,b,y_1,y_2...]$，左右两部分做差时正好抵消了，所以选哪个中位数都行\n\n关于选择中位数有更快的快速选择算法，O(n)\n","categories":["LeetCode刷题"]},{"title":"6065.按位与结果大于零的最长组合","url":"/2022/05/16/LeetCode刷题/6065.按位与结果大于零的最长组合/","content":"\n# 6065.按位与结果大于零的最长组合\n\n## 题目描述\n\n对数组nums执行按位与相当于对数组nums中的所有整数执行按位与\n\n例如，对nums=[1,5,3]来说，按位与等于1&5&3=1\n\n一个正整数数组candidates。计算candidates中的数字每种组合下按位与的结果。candidates中的每个数字在每种组合中只能使用一次。\n\n返回按位与结果大于0的最长组合的长度\n\n## 解题思路\n\n正整数数组\n\n4字节32位，对于每一位判断是否是1，是1的话放入map中\n\n构建完map后找到那个size最大的，返回里面的内容作为数组\n","categories":["LeetCode刷题"]},{"title":"0406.后继者","url":"/2022/05/16/LeetCode刷题/0406.后继者/","content":"\n# 0406.后继者\n\n## 题目描述\n\n设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。\n\n如果指定节点没有对应的“下一个”节点，则返回null。\n\n## 解题思路\n\n首先这是一个二叉搜索树\n\n找中序遍历中结点的下一个结点\n\n找那个最小的大于p的结点\n\n如果p的右子树为空，就是从root遍历\n\n```java\nwhile (root != null) {\n    if (root.val > p.val) {\n        ans = root;\n        root = root.left;\n    } else {\n        root = root.right;\n    }\n}\n```\n\n如果p的右子树不为空，就找他右子树中最左面的结点(最小的大于p的结点)\n\n最后返回ans\n","categories":["LeetCode刷题"]},{"title":"449.序列化和反序列化二叉搜索树","url":"/2022/05/13/LeetCode刷题/449.序列化和反序列化二叉搜索树/","content":"\n# 449.序列化和反序列化二叉搜索树\n\n## 题目描述\n\n将一个二叉搜索树序列化并反序列化\n\n## 解题思路\n\n因为树是二叉搜索树，所以隐含了一些信息，用先序遍历保存序列\n\n通过先序遍历的头部元素，可以定位左子树和右子树，这样就可以还原了\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"297.二叉树的序列化与反序列化","url":"/2022/05/13/LeetCode刷题/297.二叉树的序列化与反序列化/","content":"\n# 297.二叉树的序列化与反序列化\n\n## 题目描述\n\n将一个二叉树序列化再反序列化\n\n这个题与[449.序列化和反序列化二叉搜索树](/2022/05/13/LeetCode刷题/449.序列化和反序列化二叉搜索树/index.html)不同，这题的二叉树不是二叉搜索树\n\n当时拿449的用例看这个题，怎么看怎么觉得代码是相同的，后来仔细看了看原来树不是二叉搜索树\n\n## 解题思路\n\n不是二叉搜索树，需要用一些特殊的标记来标记叶子节点了\n\n用#标记null结点\n\n```java\nprivate TreeNode rdeserialize(String[] nodes) {\n    if (nodes[index].equals(\"#\")) {\n        index++;\n        return null;\n    }\n    TreeNode root = new TreeNode(Integer.parseInt(nodes[index]));\n    index++;\n    root.left = rdeserialize(nodes);\n    root.right = rdeserialize(nodes);\n    return root;\n}\n```\n\n将得到的序列以```\" \"```split，得到```String[]```\n\n用了一个全局的index来标记遍历到哪了\n\n然后递归的构建树就可以了\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"0105.一次编辑","url":"/2022/05/13/LeetCode刷题/0105.一次编辑/","content":"\n# 0105.一次编辑\n\n## 题目描述\n\n字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符\n\n给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑\n\n## 解题思路\n\n先判断长度，长度差为1和0都可能true，其余的就是false\n\n得先确定两个字符串的长度，和较长的是哪个，较短的是哪个？\n\n我对于长度差为1和为0的分开判断了\n\n长度差为0的话就遍历长度，计数不相等的字符数\n\n长度差为1的话就对长的按个删去一个字符，然后拼接两部分和短的判断，时间复杂度$O(n^2)$\n\n用双指针的话只需要时间复杂度$O(n)$\n\n```java\nint n = a.length(), m = b.length();\nif (Math.abs(n - m) > 1) return false;\nif (n > m) return oneEditAway(b, a);\nint i = 0, j = 0, cnt = 0;\nwhile (i < n && j < m && cnt <= 1) {\n    char c1 = a.charAt(i), c2 = b.charAt(j);\n    if (c1 == c2) {\n        i++; j++;\n    } else {\n        if (n == m) {\n            i++; j++; cnt++;\n        } else {\n            j++; cnt++;\n        }\n    }\n}\nreturn cnt <= 1;\n```\n\n不相等就跳过继续判断，看看不相等字符个数\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"命名规范","url":"/2022/05/12/go/命名规范/","content":"\n# 命名规范\n\n## variable\n\n简洁胜于冗长\n缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写\n变量距离其被使用的地方越远，则需要携带越多的上下文信息\n全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义\n\n## function\n\n函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的\n函数名尽量简短\n当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义\n当名为 foo 的包某个函数返回类型 T 时（T 并不是 Foo），可以在函数名中加入类型信息\n\n## package\n\n只由小写字母组成。不包含大写字母和下划线等字符\n简短并包含一定的上下文信息。例如 schema、task 等\n不要与标准库同名。例如不要使用 sync 或者 strings\n\n## 总结\n\n关于命名的大多数规范核心在于考虑上下文\n","categories":["其他"]},{"title":"实验室服务器","url":"/2022/05/11/其他/实验室服务器/","content":"\n# 实验室服务器\n\n## 新建用户\n\n创建用户```sudo useradd username -m```\n\n设置密码```sudo passwd username```\n\n切换用户```su username```\n\n删除用户```sudo userdel -r username```\n\n新建用户之后只显示$解决办法:\n\n切换到root用户下,执行命令```usermod -s /bin/bash username```\n\n## 无法联网问题\n\n登录后是不联网的，能ssh连上是因为都在校园网环境下\n\nsrun 学号+密码登录校园网\n","categories":["其他"]},{"title":"测试用例","url":"/2022/05/11/LeetCode刷题/0.测试用例/","content":"\n# 测试用例\n\n## 二维数组\n\n用正则表达式替换\n\n```\n\\[(-?[0-9]*),(-?[0-9]*)\\]\n\\{$1,$2\\}\n```\n\n好耶","categories":["其他"]},{"title":"Jupyter","url":"/2022/05/09/其他/jupyter/","content":" \n# Jupyter\n\n<hr>\n\n启动jupyter没有conda环境的内核\n\n去这个文件夹中加\n\n```C:\\Users\\ZSins7588\\AppData\\Roaming\\jupyter\\kernels\\```\n\n如加pytorch-gat\n\nkernel.json\n\n```json\n{\n \"argv\": [\n  \"D:\\\\Software\\\\anaconda\\\\python.exe\",\n  \"-m\",\n  \"ipykernel_launcher\",\n  \"-f\",\n  \"{connection_file}\"\n ],\n \"display_name\": \"gat\",\n \"language\": \"python\"\n}\n```\n\n也可以使用命令自己生成\n\n```cmd\npython -m ipykernel install --user --name pytorch-gat --display-name \"gat\"\n```\n","categories":["其他"]},{"title":"942.增减字符串匹配","url":"/2022/05/09/LeetCode刷题/942.增减字符串匹配/","content":"\n# 942.增减字符串匹配\n\n## 题目描述\n\n由范围[0,n]内所有整数组成的n+1个整数的排列序列可以表示为长度为n的字符串s，其中:\n\n    如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' \n    如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' \n\n给定一个字符串s，重构排列perm并返回它。如果有多个有效排列perm，则返回其中任何一个。\n\n## 解题思路\n\n贪心：\n\nmin=0，max=n\n\ns[i]=='I'时，就直接令perm[i]=min，同时min++\n\ns[i]=='D'时，就直接令perm[i]=max，同时max--\n\n最后给perm[n]赋值，并返回perm\n","tags":["贪心"],"categories":["LeetCode刷题"]},{"title":"442.数组中重复的数据","url":"/2022/05/09/LeetCode刷题/442.数组中重复的数据/","content":"\n# 442.数组中重复的数据\n\n## 题目描述\n\n一个长度为n的整数数组nums，其中nums的所有整数都在范围[1,n]内，且每个整数出现一次或两次\n\n找出所有出现两次的整数，并以数组形式返回\n\n要求：时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。\n\n## 解题思路\n\n因为长度为n，且数据范围是[1,n]，用桶的思想，将nums[i]放到nums[i]-1的下标处，其他数字无法重复放置，这样就可以判断出是否重复了。\n\n看题解发现这个思路叫原地hash：hash(value)=value−1\n","tags":["原地hash"],"categories":["LeetCode刷题"]},{"title":"433.最小基因变化","url":"/2022/05/09/LeetCode刷题/433.最小基因变化/","content":"\n# 433.最小基因变化\n\n## 题目描述\n\n基因序列可以表示为一条由8个字符组成的字符串，其中每个字符都是'A'、'C'、'G'和'T'之一\n\n假设我们需要调查从基因序列start变为end所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化\n\n    例如，\"AACCGGTT\" --> \"AACCGGTA\"就是一次基因变化\n\n另有一个基因库bank记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列\n\n给你两个基因序列start和end，以及一个基因库bank，找出并返回能够使start变化为end所需的最少变化次数\n\n如果无法完成此基因变化，返回-1\n\n注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。\n\n## 解题思路\n\n如果start不在bank里，将其放入bank，如果end不在bank里，返回-1\n\n根据bank的内容构建图，如果两个染色体的基因相差位数为1，这两个染色体就存在一条边\n\n从start开始BFS，直到找到end，如果找不到返回-1。找到了就返回路径\n","tags":["图"],"categories":["LeetCode刷题"]},{"title":"1823.找出游戏的获胜者","url":"/2022/05/06/LeetCode刷题/1823.找出游戏的获胜者/","content":"\n# 1823.找出游戏的获胜者\n\n## 题目描述\n\n约瑟夫问题\n\n## 解题思路\n\n1. 常规的循环链表，时间复杂度为O(nk)\n\n2. 数学的方法，递归\n\n    ```java\n        public int findTheWinner(int n, int k) {\n        if (n == 1) {\n            return 1;\n        }\n        return (k + findTheWinner(n - 1, k) - 1) % n + 1;\n    }\n    ```\n\n    时间复杂度O(n)\n\n    k是当前的位置，去掉这个人\n\n    然后把下一个人的位置当做1\n","categories":["LeetCode刷题"]},{"title":"1720.解码异或后的数组","url":"/2022/05/06/LeetCode刷题/1720.解码异或后的数组/","content":"\n# 1720.解码异或后的数组\n\n主要是了解一下异或的性质\n\n异或自身奇数次等于自身\n\n相同数值异或，结果为0\n\n任意数值与0进行异或，结果为数值本身\n\n异或本身满足交换律\n\n```A&(A-1)```去掉最后一位1\n\n```A&1==0```判断奇偶\n\n","categories":["LeetCode刷题"]},{"title":"1447.最简分数","url":"/2022/05/06/LeetCode刷题/1447.最简分数/","content":"\n# 1447.最简分数\n\n## 题目描述\n\n一个整数n，返回所有0到1之间（不包括0和1）满足分母小于等于n的最简分数\n\n分数可以以任意顺序返回\n\n## 解题思路\n\n只能暴力，和质数没啥关系\n\n复习一下辗转相除法求最大公约数\n\n```java\nprivate int gcd(int i, int j) {\n    if (j == 0) {\n        return i;\n    } else {\n        return gcd(j, i % j);\n    }\n}\n```\n","categories":["LeetCode刷题"]},{"title":"713.乘积小于K的子数组","url":"/2022/05/06/LeetCode刷题/713.乘积小于K的子数组/","content":"\n# 713.乘积小于K的子数组\n\n## 题目描述\n\n一个整数数组nums和一个整数k\n\n返回子数组内所有元素的乘积严格小于k的连续子数组的数目\n\n## 解题思路\n\n双指针\n\n子数组的下标以j结尾的，从i到j的子数组数目为j-i+1\n\n然后维护i,j即可\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"6053.统计网格图中没有被保卫的格子数","url":"/2022/05/02/LeetCode刷题/6053.统计网格图中没有被保卫的格子数/","content":"\n# 6053.统计网格图中没有被保卫的格子数\n\n## 题目描述\n\n两个整数m和n表示一个下标从0开始的$m \\times n$网格图\n\n两个二维整数数组guards和walls，其中guards[i]=[rowi,coli]且walls[j]=[rowj,colj]，分别表示第i 个警卫和第j座墙所在的位置\n\n一个警卫能看到4个坐标轴方向（即东、南、西、北）的 所有格子，除非他们被一座墙或者另外一个警卫挡住了视线。\n\n如果一个格子能被至少一个警卫看到，那么我们说这个格子被保卫了。\n\n返回空格子中，有多少个格子是没被保卫的\n\n## 解题思路\n\n看见一个纯暴力的时间100%，为什么我的时间比他的长呢\n\n因为我将guards和walls合并了，然后分别按x和y的坐标排序一次，当时感觉这样会优化，但好像是没有必要的，因为都是对整个地图遍历一遍\n","categories":["LeetCode刷题"]},{"title":"2256.最小平均差","url":"/2022/05/02/LeetCode刷题/2256.最小平均差/","content":"\n# 2256.最小平均差\n\n## 题目描述\n\n一个下标从0开始长度为n的整数数组nums\n\n下标i处的平均差指的是nums中前i+1个元素平均值和后n-i-1个元素平均值的绝对差。两个平均值都需要向下取整到最近的整数\n\n返回产生最小平均差的下标。如果有多个下标最小平均差相等，返回最小的一个下标\n\n## 解题思路\n\n用left[]和right[]记录从左开始和从右开始的累加和\n\n然后因为要向下取整用int求求均值，然后和最小均差做比较，记录index\n","categories":["LeetCode刷题"]},{"title":"2261.含最多K个可整除元素的子数组","url":"/2022/05/02/LeetCode刷题/2261.含最多K个可整除元素的子数组/","content":"\n# 2261.含最多K个可整除元素的子数组\n\n## 题目描述\n\n一个整数数组nums和两个整数k和p，找出并返回满足要求的不同的子数组数，要求子数组中最多k个可被p整除的元素。\n\n如果满足下述条件之一，则认为数组nums1和nums2是不同数组：\n\n    两数组长度不同\n    \n    存在至少一个下标i满足nums1[i]!=nums2[i]\n\n子数组定义为：数组中的连续元素组成的一个非空序列\n\n## 解题思路\n\n```1<=nums.length<=200```\n\n这题我又想复杂了，我是找到了所有能整除的下标，然后分0个、1个、...、k个的情况来讨论，时间上和O(n^2)好像也一样[捂脸.jpg]\n\n直接两次循环然后去重即可\n\n```java\npublic int countDistinct(int[] nums, int k, int p) {\n    int ans=0;\n    Set<String> set=new HashSet<>();//去重使用\n    for (int i = 0; i < nums.length; i++) {\n        int cnt=0;//保存当前子串中可被 p 整除的元素的数量\n        StringBuilder builder=new StringBuilder();\n        for (int j = i; j >= 0; j--) {\n            builder.append(nums[j]+\" \");//必须要空格，不然不能去重\n            if(nums[j]%p==0) cnt++;\n            if(cnt<=k&&!set.contains(builder.toString())) {\n                set.add(builder.toString());//使用HashSet进行子数组进行去重\n                ans++;\n            }\n        }\n    }\n    \n    return ans;\n}\n```\n\nJava中的Set不能将```Integer[]```和```List<>```去重，但是可以用字符串保存信息，这样就可以通过list去重了\n","categories":["LeetCode刷题"]},{"title":"2260.必须拿起的最小连续卡牌数","url":"/2022/05/02/LeetCode刷题/2260.必须拿起的最小连续卡牌数/","content":"\n# 2260.必须拿起的最小连续卡牌数\n\n## 题目描述\n\n一个整数数组cards，其中cards[i]表示第i张卡牌的值。如果两张卡牌的值相同，则认为这一对卡牌匹配 。\n\n返回必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 -1。\n\n## 解题思路\n\n用```Map<Integer, List<Integer>>```表示一个数，和这个数对应的所有下标\n\n然后遍历Map取差值最小的即可\n","categories":["LeetCode刷题"]},{"title":"1305.两棵二叉搜索树中的所有元素","url":"/2022/05/02/LeetCode刷题/1305.两棵二叉搜索树中的所有元素/","content":"\n# 1305.两棵二叉搜索树中的所有元素\n\n## 題目描述\n\n给两个二叉搜索树，然后返回一个元素列表，列表中包含所有节点的值，并且使从小到大排序的\n\n## 解题思路\n\n我竟然想到了拿两个指针来DFS，然后遍历时发现出来各种重复的元素，这肯定不对\n\n将两棵树先序遍历，得到两个链表\n\n将两个有序链表合并就是ans\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"2259.移除指定数字得到的最大结果","url":"/2022/05/02/LeetCode刷题/2259.移除指定数字得到的最大结果/","content":"\n# 2259.移除指定数字得到的最大结果\n\n## 题目描述\n\n一个表示某个正整数的字符串number和一个字符digit\n\n从number中恰好移除一个等于digit的字符后，找出并返回按十进制表示最大的结果字符串\n\n生成的测试用例满足digit在number中出现至少一次\n\n## 解题思路\n\n结果的位数是确定的，肯定会将number移去一位\n\n遍历number，判断和digit位相同的下一位，如果比digit大直接结束，不然就向后遍历\n\n因为比digit大肯定是最大的了，因为当前位大，如果比digit小的话当前位为digit更大，所以向后遍历，即使都比digit小，那对数的大小影响小的也是位数低的\n","categories":["LeetCode刷题"]},{"title":"591.标签验证器","url":"/2022/05/02/LeetCode刷题/591.标签验证器/","content":"\n# 591.标签验证器\n\n## 题目描述\n\n就是写一个语法分析器，大模拟题\n\n```html\n<TAG>CONTEXT<\\TAG>\n<![DATA[DATACONTEXT]]>\n```\n\n其中第一种标签可以嵌套，第一种标签的内容可以是第二种标签\n\n具体的就不再这里描述了\n\n## 解题思路\n\n代码必须被合法的闭合标签包围。否则，代码是无效的。\n\n整个代码块是被一个大标签所包围，不断嵌套的，```<A><\\A><B><\\B>```是不合法的\n\n1. 栈来模拟——太麻烦了，偷懒没写\n\n    有时间要好好看看编译原理的递归下降法这，去年就没学太好\n\n2. 正则\n\n   ```java\n   String CDATA_CONTENT_PATTERN = \"<!\\\\[CDATA\\\\[.*?]]>\";\n    //()标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。\n    //[]标记一个中括号表达式的开始,表示的是匹配的范围，要匹配[使用\\[。\n    String TAG_CONTENT_PATTERN = \"<([A-Z]{1,9})>[^<]*</\\\\1>\";\n    code = code.replaceAll(CDATA_CONTENT_PATTERN, \"#\");\n    String temp = code;\n    while (true) {\n        code = code.replaceFirst(TAG_CONTENT_PATTERN, \"#\");\n        if (temp.equals(code)) {\n            break;\n        } else {\n            temp = code;\n        }\n    }\n    return code.equals(\"#\");\n   ```\n","tags":["正则表达式"],"categories":["LeetCode刷题"]},{"title":"427.建立四叉树","url":"/2022/05/02/LeetCode刷题/427.建立四叉树/","content":"\n# 427.建立四叉树\n\n## 题目描述\n\n最开始这题没读明白，看了给的用例才明白\n\n一个正方形矩阵他的值不是1就是0，然后从中心的位置将其分为四部分，规则如下：\n\n如果某一部分的值相等，即全为1或全为0，为这个区域设置节点，该节点为叶子结点(isLeaf=true)，该节点的val设置为该区域的值\n\n如果该部分值不相等，就再将该区域以中心位置分为4个部分，isLeaf设为false，val值随意\n\n当区域被划分划分，到最后会是$1\\times 1$的方格，就一定是叶子结点了，到此为止一颗树就建完了\n\n## 解题思路\n\n使用的数据结构是多叉树\n\nDFS递归建树即可，用(a,b,c,d)标记左上点和右下点\n\n遍历每个小区域判断该区域值是否相等\n\n返回root\n","tags":["树","DFS"],"categories":["LeetCode刷题"]},{"title":"883.三维形体投影面积","url":"/2022/04/28/LeetCode刷题/883.三维形体投影面积/","content":"\n# 883.三维形体投影面积\n\n## 题目描述\n\n在$n \\times n$的网格grid中,放置了一些与x,y,z三轴对齐的$1 \\times 1 \\times 1$立方体\n\n每个值v=grid[i][j]表示v个正方体叠放在单元格(i,j) 上\n\n查看这些立方体在xy、yz和zx平面上的投影\n\n返回所有三个投影的总面积\n\n## 解题思路\n\nxy面的投影就是看该点是否存在正方体\n\nyz和xz面的投影是看某行某列最大的正方体个数\n\n因为是$n \\times n$的网格，所以不需要两次for循环，一次for循环就可以\n","categories":["LeetCode刷题"]},{"title":"905.按奇偶排序数组","url":"/2022/04/28/LeetCode刷题/905.按奇偶排序数组/","content":"\n# 905.按奇偶排序数组\n\n## 题目描述\n\n一个整数数组nums，将nums中的的所有偶数元素移动到数组的前面，后跟所有奇数元素\n\n返回满足此条件的任一数组作为答案\n\n## 解题思路\n\n```java\nint left = 0, right = n - 1;\nwhile (left < right) {\n    while (left < n && nums[left] % 2 == 0) {\n        left++;\n    }\n    while (right >= 0 && nums[right] % 2 == 1) {\n        right--;\n    }\n    if (left < right) {\n        swap(nums, left, right);\n    }\n}\n```\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"417.太平洋大西洋水流问题","url":"/2022/04/28/LeetCode刷题/417.太平洋大西洋水流问题/","content":"\n# 417.太平洋大西洋水流问题\n\n## 题目描述\n\n有一个$m\\times n$的矩形岛屿，与太平洋和大西洋相邻\n\n太平洋处于大陆的左边界和上边界，而大西洋处于大陆的右边界和下边界\n\n岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\n\n返回网格坐标result的2D列表，其中result[i]=[ri,ci]表示雨水从单元格(ri,ci)流动既可流向太平洋也可流向大西洋\n\n## 解题思路\n\n最开始看题没看懂，是一个点他的水既可以流向太平洋也可以流向大西洋，如果对每个点进行遍历，判断该点是否满足条件是可以的，BFS即可，但是时间复杂度会高一些\n\n逆向思维，让水往高处流，将整个岛分成两个部分，左上和右下，将这些边缘点放入两个队列中\n\n然后对这两个队列进行BFS,保存能由边缘流到的位置，得到两个矩阵A和P\n\n对矩阵A和P进行判断，同时能够流到就将该点放入result中\n","categories":["LeetCode刷题"]},{"title":"398.随机数索引","url":"/2022/04/28/LeetCode刷题/398.随机数索引/","content":"\n# 398.随机数索引\n\n## 随机数索引\n\n一个可能含有重复元素的整数数组nums，随机输出给定的目标数字target的索引\n\n假设给定的数字一定存在于数组中\n\n## 解题思路\n\n用一个```Map<Integer, Set<Integer>> index;```保存数字及其对对应的索引们，然后去数时根据set的size取出随机一个数，这个下标就是答案\n","categories":["LeetCode刷题"]},{"title":"6043.统计包含每个点的矩形数目","url":"/2022/04/24/LeetCode刷题/6043.统计包含每个点的矩形数目/","content":"\n# 6043.统计包含每个点的矩形数目\n\n## 题目描述\n\n一个二维整数数组rectangles，其中rectangles[i]=[li,hi]表示第i个矩形长为li高为hi。一个二维整数数组points，其中points[j]=[xj,yj]是坐标为(xj,yj)的一个点。\n\n第i个矩形的左下角在(0,0)处，右上角在(li,hi)。\n\n返回一个整数数组count，长度为points.length，其中count[j]是包含第j个点的矩形数目\n\n如果一个点刚好在矩形的边上，这个点也被视为被矩形包含。\n\n## 解题思路\n\n最开始暴力了一遍，发现不行，TLE\n\n然后想到了排序，将矩形排序，然后二分判断\n\n思路对了，但是实现方式不对，偏差很大\n\n我想的是将x排序如果相等再排y然后找到每个点的临界index作为ans[i]\n\n注意到题目中说了纵坐标的范围时0~100，所以将纵坐标相同的点都放到list中去，然后对所有的list排序，这样排序更省时间，除此之外找到每个点的临界index也更方便\n","categories":["LeetCode刷题"]},{"title":"Set","url":"/2022/04/24/Java基础/Set/","content":"\n# Set\n\njava中是没有c++类型的pair的\n\n## HashSet\n\n通过计算hash来判断是否存在，这样的话想存储一些自定义类型就得重写hashcode方法\n\n","categories":["Java基础"]},{"title":"587.安装栅栏","url":"/2022/04/24/LeetCode刷题/587.安装栅栏/","content":"\n# 587.安装栅栏\n\n## 题目描述\n\n在二维的花园中，有(x,y)一些树，用最短的绳子围起所有的树\n\n找到所有栅栏边界的树的坐标\n\n## 解题思路\n\n人傻了，我是谁，我在哪\n\n将这个凸包分为上凸壳和下凸壳\n\n对x进行从小到大排序，如果x相等则对y进行从小到大排序\n\n用一个栈维护所有的边界点，先从先往后遍历构建上凸壳，再从后往前遍历构建下凸壳\n\n怎么来维护这个栈呢？根据两条边的位置关系来判断\n\n我裂开了，写了两个多小时，发现还是自己写不出来，各种边界情况错误，索性直接用了现成的\n\n```java\n//subtraction(b,a)求的是向量ab  subtraction(c,a)求的是向量ac\nint[] subtraction(int[] a, int[] b) { // 向量相减\n    return new int[]{a[0] - b[0], a[1] - b[1]};\n}\n\n//叉乘！！！！！\n//叉乘公式定义获得到的值k就是k=a.x*b.y-b.x*a.y\n//如果k>0时，那么a正旋转到b的角度为<180°，如果k<0，那么a正旋转到b的角度为>180°,如果k=0 那么a，b向量平行。\ndouble cross(int[] a, int[] b) { // 叉乘\n    return a[0] * b[1] - a[1] * b[0];\n}\n\n//通过平面两点向量叉乘判断当前ac向量是在顺时针方向还是逆时针方向\ndouble getArea(int[] a, int[] b, int[] c) { //向量ab转为向量ac过程中扫过的面积\n    return cross(subtraction(b, a), subtraction(c, a));\n}\n```\n\n需要注意的点：\n\n1. 维护栈的元素时不是用的if,而是用的while，需要多次判断当前点和之前点\n\n2. 第一部分的上凸壳需要用visit来标注，如果是上凸壳在构建下凸壳时不能删除，也不能加入到下凸壳中\n\n3. 构建上凸壳时不能给起点标记visit不然会导致构建下凸壳时无法闭合\n\n4. 上凸壳栈元素>2时才能开始维护，栈中元素数量大于上凸壳点数时才维护下凸壳\n","tags":["计算几何"],"categories":["LeetCode刷题"]},{"title":"388.文件的最长绝对路径","url":"/2022/04/21/LeetCode刷题/388.文件的最长绝对路径/","content":"\n# 388.文件的最长绝对路径\n\n## 题目描述\n\n{%asset_img 388.mdir.jpg 文件树状图 %}\n\n文件系统中的每个文件和文件夹都有一个唯一的绝对路径，所有路径用'/'连接\n\n给定一个以上述格式表示文件系统的字符串input，返回文件系统中指向**文件**的最长绝对路径的长度\n\n如果系统中没有文件，返回0\n\n## 解题思路\n\n需要建立一个树状结构\n\n```java\nclass TreeNode {\n    boolean isDirectionary;\n    Set<TreeNode> elements;\n    String path;\n    int rank;\n\n    TreeNode() {\n        elements = new HashSet<>();\n    }\n}\n```\n\n需要判断这个结点是不是文件夹，还是文件，其次需要保存当前节点的所有子节点，rank是路径等级，path是当前节点名\n\n想求最长路径呢，其实就是个DFS的过程，但是显然本题不需要建立完整的树形结构\n\n用一个栈，栈顶是当前的路径，然后不断的向里面加该文件夹的文件和文件夹，文件夹入栈\n\n其中需要涉及到回溯的问题，比如不断更深层的文件夹查找，查找到底的话会返回上一级\n\n其中根据'\\t'的数量来判断当前文件的层级，这个层级在回溯时需要用到，回溯就是弹出栈顶的元素\n\n遇到文件就求当前路径长度并和ans对比，最后返回ans\n","tags":["栈"],"categories":["LeetCode刷题"]},{"title":"821.字符的最短距离","url":"/2022/04/21/LeetCode刷题/821.字符的最短距离/","content":"\n# 821.字符的最短距离\n\n## 题目描述\n\n一个字符串s和一个字符c，且c是s中出现过的字符\n\n返回一个整数数组answer，其中answer.length==s.length且answer[i]是s中从下标i到离它最近的字符c的距离\n\n## 解题思路\n\n两遍扫描，从前向后一遍，从后向前一遍\n\n然后更新ans取min\n","categories":["LeetCode刷题"]},{"title":"spring-mvc","url":"/2022/04/18/SSM/spring-mvc/","content":"\n# spring-mvc\n\n## 错误汇总\n\nCaused by: java.lang.IllegalArgumentException: 找到多个名为spring_web的片段。这是不合法的相对排序。有关详细信息\n\n产生原因的话有：\n    依赖冲突，解决冲突就行,spring的web包和webmvc包冲突，webmvc中包含了这个web的jar\n\n将web这个包在pom里的scope设置为provided即可\n","categories":["其他"]},{"title":"6072.转角路径的乘积中最多能有几个尾随零","url":"/2022/04/17/LeetCode刷题/6072.转角路径的乘积中最多能有几个尾随零/","content":"\n# 6072.转角路径的乘积中最多能有几个尾随零\n\n## 题目描述\n\n## 解题思路\n\n这个题即使先将给定的数组按2和5因子过滤一遍，比如13就变成1，14就变成2这样，然后再去求乘法，也会溢出\n\n转角路径有六种情况：\n    1. 横着的\n    2. 竖着的\n    3. 左到右，然后向上\n    4. 左到右，然后向下\n    5. 右到左，然后向上\n    6. 右到左，然后向下\n\n因为是求尾随0的个数，所以直接将整排整列乘起来就行了，因为多乘一个数也不会影响结果\n\n借鉴[238.除自身以外数组的乘积](/2022/04/12/LeetCode刷题/238.除自身以外数组的乘积/index.html)的思路\n\n需要先构建从左到右，从右到左，从上到下，从下到上的乘积\n\n对于(i,j),想求他的转角路径，比如左到右然后向上，就是```left2right[i][j]*down2up[i][j]*grid[i][j]```\n\n然后求最大的尾随零的个数\n\n但是这样会导致溢出，解决办法如下：\n\n    用facter[][][]记录2和5的因子的个数，同时left2right也不算乘积了，也直接记录2和5因子的个数\n\n    ```Math.min(down2up[i][j][1] + left2right[i][j][1] + facter[i][j][1],down2up[i][j][0] + left2right[i][j][0] + facter[i][j][0]);```\n\n    然后求6种转角路径的最多尾随0的个数\n\n时间复杂度为O(mn)\n","categories":["LeetCode刷题"]},{"title":"72.编辑距离","url":"/2022/04/17/LeetCode刷题/72.编辑距离/","content":"\n# 72.编辑距离\n\n## 题目描述\n\n两个单词word1和word2，返回将word1转换成word2所使用的最少操作数\n\n对一个单词进行如下三种操作：\n\n    * 插入一个字符\n    * 删除一个字符\n    * 替换一个字符\n\n## 解题思路\n\n所有的操作相当于只有\n\n    1. 在word1中插入一个字符\n    2. 在word2中插入一个字符\n    3. 修改word1的一个字符\n\ndp[i][j]表示word1的前i个字母和word2的前j个字母之间的编辑距离\n\n```java\nint left = dp[i - 1][j] + 1;\nint down = dp[i][j - 1] + 1;\nint leftDown = dp[i - 1][j - 1];\nif (word1.charAt(i - 1) != word2.charAt(j - 1)) {\n    leftDown++;\n}\ndp[i][j] = Math.min(left, Math.min(down, leftDown));\n```\n\n如果两个单词当前的字母相同，就不用增加步数\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"42.接雨水","url":"/2022/04/17/LeetCode刷题/42.接雨水/","content":"\n# 42.接雨水\n\n## 题目描述\n\n给定n个非负整数表示每个宽度为1的柱子的高度图，计算下雨之后能接多少雨水\n\n{%asset_img 42.接雨水\\rainwatertrap.png 示意图 %}\n\n## 解题思路\n\n找到每一个柱子左面的最大高度和右面的最大高度\n\n雨水只能下到min(left,right)，最高只能下到短板处，然后再减去当前的高度\n\n求和即可\n","categories":["LeetCode刷题"]},{"title":"337.打家劫舍III","url":"/2022/04/14/LeetCode刷题/337.打家劫舍 III/","content":"\n# 337.打家劫舍III\n\n## 题目描述\n\n与[198.打家劫舍](/2022/03/31/LeetCode刷题/198.打家劫舍/index.html)类似\n\n行窃地区是树型，这个地区只有一个入口root\n\n两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警\n\n## 解题思路\n\n最开始我想的是和打家劫舍一样的dp思路，从root开始DFS搜索子节点，父节点被偷则子节点就不能被偷，但是测试后发现是错的，因为树有两个分支\n\n所以应该从叶子结点向上搜索\n\n用一个map来保存结点和结点的目标值\n\n```java\nif (root.left != null && root.right != null) {\n    Integer[] right = dp.get(root.right);\n    Integer[] left = dp.get(root.left);\n    temp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    temp[1] = left[0] + right[0] + root.val;\n}\n```\n\n其余类型的结点与之类似\n","tags":["树","dp"],"categories":["LeetCode刷题"]},{"title":"380.O(1) 时间插入、删除和获取随机元素","url":"/2022/04/13/LeetCode刷题/380.O(1) 时间插入、删除和获取随机元素/","content":"\n# 380.O(1) 时间插入、删除和获取随机元素\n\n## 题目描述\n\n插入删除和随机取一个元素都必须在O(1)的时间内完成\n\n## 解题思路\n\n单独的hashset可以完成插入删除，但是不能完成O(1)的获取随机元素\n\n所以用一个List来保存数据，用一个hashmap来保存数据对应的下标，在插入删除时维护好就可以在O(1)的时间内获取随机元素\n\n```java\npublic int getRandom() {\n    int index = random.nextInt(nums.size());\n    return nums.get(index);\n}\n```\n","categories":["LeetCode刷题"]},{"title":"309.最佳买卖股票时机含冷冻期","url":"/2022/04/13/LeetCode刷题/309.最佳买卖股票时机含冷冻期/","content":"\n# 309.最佳买卖股票时机含冷冻期\n\n## 题目描述\n\n与[121.买卖股票的最佳时期](/2022/03/21/LeetCode刷题/121.买卖股票的最佳时期/index.html)类似\n\n- 可以多次交易\n- 卖出后第二天不能买入\n- 再次买入前必须卖出之前的股票\n\n## 解题思路\n\ndp[n][3]，dp表示累计最大收益\n\ndp[i][0]表示目前持有一支股票\n\n    dp[i][0] = max(dp[i-1][0],dp[i-1][2]-prices[i])\n\n    前一天就有股票，或者不持有然后今天买了股票\n\ndp[i][1]表示目前不持有任何股票，并且处于冷冻期中\n\n    dp[i][1] = dp[i-1][0]+prices[i]\n\n    前一天还持有股票，然后今天卖了\n\ndp[i][2]表示目前不持有任何股票，并且不处于冷冻期中\n\n    dp[i][2] = max(dp[i-1][1],dp[i-1][2])\n\n    第i天结束时冷却期也结束了，说明是第i-1天卖的，或者i-1天不持有\n\n初始条件为dp[0][0]=-prices[0]\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"240.搜索二维矩阵II","url":"/2022/04/12/LeetCode刷题/240.搜索二维矩阵II/","content":"\n# 240.搜索二维矩阵II\n\n## 题目描述\n\n判断在矩阵中能否搜索得到目标值target\n\n矩阵有如下特性：\n\n    每行的元素从左到右升序排列。\n    \n    每列的元素从上到下升序排列。\n\n## 解题思路\n\n因为矩阵的行列有序特性，所以这道题肯定不是暴力查找($O(mn)$)\n\n用一个rowBound和colBound来标记矩阵的右下边界，i,j来标记矩阵的左上边界\n\n然后逐步的缩小范围，最后就能判断是否能查找到target\n\n```java\nwhile (i <= rowBound && j <= colBound) {\n    if (target > matrix[i][colBound]) {\n        i++;\n        continue;\n    }\n    if (target > matrix[rowBound][j]) {\n        j++;\n        continue;\n    }\n    while (colBound > j && matrix[i][colBound] > target) {\n        colBound--;\n    }\n    while (rowBound > i && matrix[rowBound][j] > target) {\n        rowBound--;\n    }\n    if (i == rowBound && j == colBound) {\n        return matrix[rowBound][colBound] == target;\n    } else if (matrix[rowBound][j] == target) {\n        return true;\n    } else if (matrix[i][colBound] == target) {\n        return true;\n    }\n}\nif (i >= m || j >= n) {\n    return false;\n} else {\n    return matrix[i][j] == target;\n}\n```\n\n虽然我写的时间复杂度也是O(m+n)，但还是比题解复杂了。代码没有题解的清晰，题解是Z字形查找，从右上角开始，但思路是一样的\n","categories":["LeetCode刷题"]},{"title":"238.除自身以外数组的乘积","url":"/2022/04/12/LeetCode刷题/238.除自身以外数组的乘积/","content":"\n# 238.除自身以外数组的乘积\n\n## 题目描述\n\n给一个整数数组nums，返回数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积\n\n要求：O(n)并且不能使用除法，保证数据在INT范围内\n\n## 解题思路\n\n将answer[i]分解为L[i-1],R[i+1]\n\n其中L[i-1]是从左向右乘，从第0个元素乘到第i-1个元素，R[i+1]是从右往左乘，从最后一个元素乘到第i+1个元素\n\n再处理一下answer[0]和answer[n-1]的边界即可","categories":["LeetCode刷题"]},{"title":"215.数组中的第K个最大元素","url":"/2022/04/12/LeetCode刷题/215.数组中的第K个最大元素/","content":"\n# 215.数组中的第K个最大元素\n\n## 题目描述\n\n给定整数数组nums和整数k，返回数组中第k个最大的元素\n\n需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素\n\n也就是数组排序后的nums[k]\n\n## 解题思路\n\n1. 小顶堆\n\n    使用一个容量为k的小顶堆，小顶堆中保存的是k个最大的元素，当当前数比堆顶元素大的时候，需要更新小顶堆\n\n    最后返回堆顶元素即可\n\n    这样只保留k个最大的，空间较优，数据不需要一次性读入内存\n\n    时间复杂度：O(NlogK)\n\n2. 基于快速排序的快速选择\n\n    对于q,左区间都比a[q]小，右区间都比a[q]大\n\n    当q是要找的第k大时候直接返回nums[q]，不然根据条件再次对左右区间进行操作\n\n通过这道题对快速排序的理解加深了\n","categories":["LeetCode刷题"]},{"title":"300.最长递增子序列","url":"/2022/04/11/LeetCode刷题/300.最长递增子序列/","content":"\n# 300.最长递增子序列\n\n## 题目描述\n\n一个整数数组nums，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序\n\n例如，[3,6,2,7]是数组[0,3,1,6,2,2,7]的子序列\n\n## 解题思路\n\n```java\ndp[0] = 0;\nfor (int i = 1; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n        if (nums[i] > nums[j]) {\n            dp[i] = Math.max(dp[i], dp[j] + 1);\n        }\n    }\n}\n```\n\n对于每个dp[i]找从0到i,如果nums[i] > nums[j]就进行更新即可\n\n最后找到dp中最大的数\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"357.统计各位数字都不同的数字个数","url":"/2022/04/11/LeetCode刷题/357.统计各位数字都不同的数字个数/","content":"\n# 357.统计各位数字都不同的数字个数\n\n## 题目描述\n\n给一个整数n，统计并返回各位数字都不同的数字x的个数，其中$0<=x<10^n$\n\n## 解题思路\n\nn=0的话只有一个0\n\nn=1的话有0-9\n\n因为0不能做开头的数字，也就是0只是0，其余的数字后面可以再接数字\n\n对1-9进行搜索，每多一位时可用数字就少1，可以求出该层的数字\n\n在求每一层的同时对ans进行累加即可\n","categories":["LeetCode刷题"]},{"title":"152.乘积最大子数组","url":"/2022/04/10/LeetCode刷题/152.乘积最大子数组/","content":"\n# 152.乘积最大子数组\n\n## 题目描述\n\n数组中乘积最大的非空连续子数组,此数组中最少包含一个数\n\n## 解题思路\n\n这个题和最长连续子列和应该是类似的，不过一个是乘法一个是加法\n\n```java\npublic int maxProduct(int[] nums) {\n    int ans = Integer.MIN_VALUE;\n    int max = 1, min = 1;\n    for (int num : nums) {\n        if (num < 0) {\n            int temp = max;\n            max = min;\n            min = temp;\n        }\n        max = Math.max(max * num, num);\n        min = Math.min(min * num, num);\n\n        ans = Math.max(max, ans);\n    }\n    return ans;\n}\n```\n\n根据加法的特性，如果一个数成负数了，那之前的就可以抛弃了，因为加上一个数这个负数也会起作用\n\n但是乘法不一样，负数乘负数会变为正数\n\n所以我们需要维护一个min，max和ans\n\n当当前数是负数时，将min和max互换，因为最小数乘一个负数之后会变为正数\n\n同时在循环中更新ans\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"CMB.公园规划","url":"/2022/04/10/LeetCode刷题/CMB.公园规划/","content":"\n# CMB.公园规划\n\n## 题目描述\n\n一条路他的两端不能放同一种花\n\n一个花坛与其相连的两个花坛也不能放同一种花\n\n有num个花坛，num-1条小路\n\n## 解题思路\n\n翻译过来就是有一个树，给树的结点赋值\n\n对于每个子树：所有的子结点不能赋相同的值，并且这些叶子结点不能与根节点赋相同的值\n\n所以这道题就是求最大子节点数量，然后+1返回即可\n","tags":["模拟"],"categories":["LeetCode刷题"]},{"title":"OfferII.114.外星文字典","url":"/2022/04/10/LeetCode刷题/OfferII.114.外星文字典/","content":"\n# 剑指OfferII114.外星文字典\n\n## 题目描述\n\n现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。\n\n给定一个字符串列表words，作为这门语言的词典，words 中的字符串已经按这门新语言的字母顺序进行了排序\n\n根据该词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。若不存在合法字母顺序，返回\"\"。若存在多种可能的合法字母顺序，返回其中任意一种顺序即可\n\n字符串s字典顺序小于字符串t有两种情况：\n\n    1. 在第一个不同字母处，如果s中的字母在这门外星语言的字母顺序中位于t中字母之前，那么s的字典顺序小于t。\n    \n    2. 如果前面min(s.length, t.length)字母都相同，那么s.length<t.length时，s的字典顺序也小于t\n\n## 解题思路\n\n给定了一个字符串数组，字符串数组中的数组按字符串排好序了\n\n首先需要知道这个词典里所有用到的字母，这样的话就是遍历一次所有字符串中的所有字符\n\n这样就确定了图中的所有点，然后i和i+1个字符串做比较，得到边，同时根据字典序的规则2判断这两个字符串是不是按字典序排序的，如果不是就说明不存在正确字典序\n\n然后就是根据图判断有没有环，进行拓扑排序\n\n## 拓扑排序中有多个入度为0的点的思考\n\n题目中说**若存在多种可能的合法字母顺序，返回其中任意一种顺序即可**，这样的话就是对应的拓扑排序中有多个入度为0的点，这些入度为0的点不确定\n\n```\nab\nac\ndb\ndc\n```\n\n根据上面能确定的是b>c,a>d,其余的不确定，所以答案可能有多种","tags":["图"],"categories":["LeetCode刷题"]},{"title":"148.排序链表","url":"/2022/04/09/LeetCode刷题/148.排序链表/","content":"\n# 148.排序链表\n\n## 题目描述\n\n给定一个链表，按升序排序，并返回头结点\n\n## 解题思路\n\n归并排序,写了好久发现又写的有点墨迹，我想直接对node进行连接这样可以省一些空间，然后按照数组归并的思路head,mid,tail分成区间，然后将每个区间排序\n\n这样就导致了一些bug，比如(mid,tail)区间中的顺序变化了，导致了合并时无法正确判断(head,mid)区间的中止，导致错误\n\n题解将数组划分区间时使这个区间的下一个结点为null\n\n```java\nif (head.next == tail) {\n    head.next = null;\n    return head;\n}\n```\n\n所以在合并时也很方便，直接判断是否为null就可以判断该区间是否结束了，也不会存在区间结束的判断问题\n","tags":["排序","链表"],"categories":["LeetCode刷题"]},{"title":"780.到达终点","url":"/2022/04/09/LeetCode刷题/780.到达终点/","content":"\n# 780.到达终点\n\n## 题目描述\n\n给定四个整数sx,sy,tx和ty\n\n如果通过一系列的转换可以从起点(sx,sy)到达终点(tx,ty)，则返回true，否则返回false\n\n从点(x,y)可以转换到(x,x+y)或者(x+y,y)。\n\n## 解题思路\n\n正向计算情况很多会超时，所以逆向回推，由tx,ty判断能不能回到sx,sy\n\n{%asset_img 780.case.png 示意图 %}\n\n$$(x,y)-->(x,x+y)||(x+y,y)$$\n\n所以逆推的话就是拿大数减去小数\n\n//tx和ty有一个大小关系，两个数都取对方的余数，就只对较大数生效\n\n```return reachingPoints(sx, sy, tx % ty, ty % tx);```\n\n当有一个数已经和其实点坐标相同时，只能动另一个数了，判断```(ty-sy)%sx==0```或者```(tx-sx)%sy==0```\n\n当tx,ty之一已经比sx,sy小的时候，就返回false\n","categories":["LeetCode刷题"]},{"title":"429.N 叉树的层序遍历","url":"/2022/04/09/LeetCode刷题/429.N 叉树的层序遍历/","content":"\n# 429.N 叉树的层序遍历\n\n## 题目描述\n\n层次遍历，返回每层的元素\n\n## 解题思路\n\n就是常规的层次遍历，用一个队列BFS\n\n但是因为要返回每一层的元素而不是整体返回，我新创建了个队列，来表示当前层的所有子节点，然后再将这个队列复制会判断isEmpty的队列\n\n实际上这样做事复杂了，在每一层时直接取一下当前队列的size然后遍历队列的size个结点就好了(这样做当前层的子节点依然可以加到队列中，代码整洁性比较好)\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"Tomcat","url":"/2022/04/08/JavaWeb/Tomcat/","content":"\n# Tomcat\n\nhtml使用传递参数时，在Servlet应该使用getParameter来获取这个参数\n\n而getAttribute是和setAttribute一起使用的，是在Servlet中设置的Attribute以供jsp使用\n\n```java\n//2. 存入request域中\nrequest.setAttribute(\"brands\",brands);\n\n//3. 转发到brand.jsp\nrequest.getRequestDispatcher(\"/brand.jsp\").forward(request,response);\n```\n\n请求转发到brand.jsp\n\n```xml\n<c:forEach items=\"${brands}\" var=\"brand\" varStatus=\"status\">\n```\n\n可以获取到brands的数据\n\n<hr>\n\nhttpServlet中的service对get和post进行了分发，所以重写doGet和doPost即可\n\n```java\nif (method.equals(\"GET\")) {\n    lastModified = this.getLastModified(req);\n    if (lastModified == -1L) {\n        this.doGet(req, resp);\n\nelse if (method.equals(\"POST\")) {\n    this.doPost(req, resp);\n```\n\nservlet-->HttpServlet-->BaseServlet-->更高层的servlet\n\n都会调用service接口\n","categories":["其他"]},{"title":"135.分发糖果","url":"/2022/04/07/LeetCode刷题/135.分发糖果/","content":"\n# 135.分发糖果\n\n## 题目描述\n\nn个孩子站成一排。一个整数数组ratings表示每个孩子的评分\n\n需要按照以下要求，给这些孩子分发糖果：\n\n    每个孩子至少分配到1个糖果。\n    \n    相邻两个孩子评分更高的孩子会获得更多的糖果。\n\n给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。\n\n## 解题思路\n\n19年小学期考试出的一道题竟然就是这道题，当时记得看了题解也没有看太明白\n\n现在虽然是看了题解的，但总归是看明白了\n\n两遍扫描：\n\n从左到右构建满足条件的一个序列，第一个孩子有1个糖果，右面的孩子要是比左面的孩子分数高就糖果数+1，不然就记为1重新开始增加\n\n然后再从右向左扫描，最右面的孩子的数量不变，然后左面的孩子要是比右面的孩子分数高就右面的孩子的糖果数+1，并和原本自己的糖果数进行比较，取较大的那个\n\nans可以在第二次从右向左扫描时直接计算得出，省去一遍遍历\n\n对于为什么从左到右扫描时直接+1就行，而从右向左扫描时需要取最大值呢，因为从右向左扫描时的正向序列已经构建好了，直接+1可能会破坏构建好的序列\n","categories":["LeetCode刷题"]},{"title":"796.旋转字符串","url":"/2022/04/07/LeetCode刷题/796.旋转字符串/","content":"\n# 796.旋转字符串\n\n## 题目描述\n\n给定两个字符串, s和goal。如果在若干次旋转操作之后，s能变成goal，那么返回true\n\ns的旋转操作就是将s最左边的字符移动到最右边\n\n## 解题思路\n\n其实并不用暴力的一次旋转一次旋转的进行判断\n\n直接s+s，然后KMP就是O(n)。```String.contains()```\n","categories":["LeetCode刷题"]},{"title":"Maven","url":"/2022/04/06/JavaWeb/Maven/","content":"\n# Maven\n\nUnable to load authentication plugin 'caching_sha2_password'\n\n在pom.xml中将mysql-connecter升级\n","categories":["其他"]},{"title":"310.最小高度树","url":"/2022/04/06/LeetCode刷题/310.最小高度树/","content":"\n# 310.最小高度树\n\n## 题目描述\n\n给一棵包含n个节点的树，标记为0到n-1。给定数字n和一个有n-1条无向边的edges列表（每一个边都是一对标签），其中```edges[i]=[ai,bi]```表示树中节点ai和bi之间存在一条无向边。\n\n可选择树中任何一个节点作为根。当选择节点x作为根节点时，设结果树的高度为h。在所有可能的树中，找到所有最小高度的树，并按任意顺序返回它们的根节点标签列表。\n\n树的高度是指根节点和叶子节点之间最长向下路径上边的数量。\n\n## 解题思路\n\n最小高度就是找最长的路径，然后在中间截断开就是最小的高度，最大的高度应该是最长路径\n\n先根据edges将每个点的边都构建好\n\n然后求出每个点的入度，因为树的边是无向的，所以出度就是入度\n\n用一个队列将入度为1的结点(叶子结点)全部放入队列中\n\n然后BFS，将这个结点移除，同时更新该节点连接的结点的入度信息\n\n如果连接结点的入度变为1，那么他就成为了叶子结点，将其放入队列中\n\n其实BFS的过程就是不断的找叶子结点，然后剥离，然后就可以找到最长的路径\n\n最后一次循环中队列中的元素就是最长路径中中间的两个结点\n","tags":["树","BFS"],"categories":["LeetCode刷题"]},{"title":"762.二进制表示中质数个计算置位","url":"/2022/04/05/LeetCode刷题/762.二进制表示中质数个计算置位/","content":"\n# 762.二进制表示中质数个计算置位\n\n## 题目描述\n\n两个整数left和right，在闭区间[left,right]范围内\n\n统计并返回计算置位位数为质数的整数个数\n\n计算置位位数就是二进制表示中1的个数\n\n## 解题思路\n\n其实很简单，求这个数的二进制中1的个数，然后判断这个数是不是质数即可\n\n然后看了题解发现，原来还可以这么干：\n\n    注意到$right<10^6<2^20$\n    \n    因此二进制中1的个数不会超过19，而不超过19的质数只有\n    \n    2, 3, 5, 7, 11, 13, 17, 19\n    \n    我们可以用一个二进制数$mask=665772=10100010100010101100_2$\n    \n    来存储这些质数，其中mask二进制的从低到高的第i位为1表示i是质数，为0表示i不是质数\n\n    设整数x的二进制中1的个数为c，若mask按位与2^c不为0，则说明c是一个质数\n","categories":["LeetCode刷题"]},{"title":"307.区域和检索 - 数组可修改","url":"/2022/04/04/LeetCode刷题/307.区域和检索 - 数组可修改/","content":"\n# 307.区域和检索 - 数组可修改\n\n## 题目描述\n\n一个数组,可以改变nums[i],可以求[left,right]的区间和\n\n## 解题思路\n\n这个题一看十分简单,感觉有坑,一写果然超时了,看了眼题解,原来有种东西叫线段树\n\n后来思考了一下这种数据结构和数组到底有什么差别,线段树应该是一种创建数组后不再增加元素,并且查询区间和的操作的频率比较大\n\n用一个数组来模拟线段树:\n\n线段树存储的信息是[s,e]范围的区间和\n\n设根节点下标为0\n\n如果一个结点在数组的下标为node，那么它的左子结点下标为node×2+1，右子结点下标为node×2+2\n\n<hr>\n\n这样的话构建线段树的代码为:\n\n```java\nprivate void build(int node, int s, int e, int[] nums) {\n    if (s == e) {\n        segmentTree[node] = nums[s];\n        return;\n    }\n    int m = s + (e - s) / 2;\n    build(node * 2 + 1, s, m, nums);\n    build(node * 2 + 2, m + 1, e, nums);\n    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n}\n```\n\nnode是当前节点的下标,[s,e]是当前节点所保存的区间和的区间,当s==e时,说明该节点保存的内容仅仅是一个数\n\n左子树的和的区间为[s,(s+e)/2],右子树的和的区间为[(s+e)/2+1,e]\n\n先递归的构建左子树,右子树,当左子树和右子树都构建完成后才能对这个节点求和.\n\n<hr>\n\n更改元素值的操作为\n\n```java\nprivate void change(int index, int val, int node, int s, int e) {\n    if (s == e) {\n        segmentTree[node] = val;\n        return;\n    }\n    int m = s + (e - s) / 2;\n    if (index <= m) {\n        change(index, val, node * 2 + 1, s, m);\n    } else {\n        change(index, val, node * 2 + 2, m + 1, e);\n    }\n    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n}\n```\n\n不断的对[s,e]进行二分,找到保存该节点的node,然后直接进行修改即可\n\n**原数组下标为index的元素并不是segmentTree[index]!!**\n\n<hr>\n\n求和的话就是判断[s,e]是在左区间还是右区间,如果是横跨了左右区间就通过(s+e)/2来分割开,然后求和\n","tags":["线段树"],"categories":["LeetCode刷题"]},{"title":"MyBatis使用","url":"/2022/04/02/JavaWeb/MyBatis使用/","content":"\n# MyBatis\n\n在pojo中的实体的属性名和数据库中的列名不相同时会导致无法正确读取数据\n\n解决办法:\n\n    1. 在写sql的时候对列名取别名使其和属性名相同\n\n        缺点:繁琐\n\n    2. 写sql片段\n\n        ```xml\n        <sql id=\"brand_colum\">\n        id,brand_name as brandName,company_name as companyName,ordered,description,status\n        </sql>\n\n        <select id=\"selectAll\" resultType=\"com.heima.pojo.Brand\">\n            select <include refid=\"brand_colum\"/> from tb_brand;\n        </select>\n        ```\n\n        缺点:不灵活\n    \n    3. resultMap\n\n        ```xml\n        <resultMap id=\"brandResultMap\" type=\"com.heima.pojo.Brand\">\n            <result column=\"brand_name\" property=\"brandName\"/>\n            <result column=\"company_name\" property=\"companyName\"/>\n        </resultMap>\n\n        <select id=\"selectAll\" resultMap=\"brandResultMap\">\n            select * from tb_brand;\n        </select>\n        ```\n\n        使用resultMap属性替换resultType属性，完成映射\n\n## .xml中传递参数\n\n```xml\n<select id=\"selectById\" parameterType=\"int\" resultMap=\"brandResultMap\">\n        select * from tb_brand where id=#{id};\n</select>\n```\n\n\\#{}:会替换为?，：为了防止sql注入\n${}:拼接sql，会存在sql注入问题\n\n${}在表名或列名不固定的情况下使用\n\nparameterType可以省略\n\n## 特殊字符的处理\n\n需要符合xml的语法规则\n\n1. 进行转义\n\n2. CDATA区\n\n## .java中接口传递多参数\n\n参数处理需要额外处理，如前后加```%```\n\n1. 散装参数\n\n   使用注解@Param(\"\")\n\n2. 对象参数\n\n    参数名和实体类的属性名应该对应\n\n3. Map参数\n\n    参数名应该和map集合的键对应\n\n以上MyBatis会自动匹配参数\n\n## 动态条件查询\n\nMyBatis提供了一些标签\n\nSQL语句随着用户输入或外部条件变化而变化，称为动态SQL\n\n### 多条件动态-多个条件有的有有的没有\n\n用where if标签\n\n```xml\n<select id=\"selectByCondition\" resultMap=\"brandResultMap\">\n    select * from tb_brand\n    <where>\n        <if test=\"status!=null\">\n            and status=#{status}\n        </if>\n        <if test=\"companyName!=null and companyName!='' \">\n            and company_name like #{companyName}\n        </if>\n        <if test=\"brandName!=null and brandName!='' \">\n            and brand_name like #{brandName}\n        </if>\n    </where>\n</select>\n```\n\n### 单条件动态查询-多个条件只有一个\n\n用choose when标签\n\n```xml\n<select id=\"selectByConditionSingle\" resultMap=\"brandResultMap\">\n    select * from tb_brand\n    where\n    <choose>\n        <when test=\"status!=null\">\n            status=#{status}\n        </when>\n        <when test=\"companyName!=null and companyName!='' \">\n            company_name like #{companyName}\n        </when>\n        <when test=\"brandName!=null and brandName!='' \">\n            brand_name like #{brandName}\n        </when>\n        <otherwise>\n            1=0\n        </otherwise>\n    </choose>\n</select>\n```\n\n## MyBatis的事务\n\n设置事务自动提交\n\n```SqlSession sqlSession = sqlSessionFactory.openSession(true);```\n\n手动提交:```sqlSession.commit();```\n\n## 插入时主键返回\n\n```xml\n<insert id=\"add\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into tb_brand(brand_name, company_name, ordered, description, status)\n        values (#{brandName},#{companyName},#{ordered},#{description},#{status});\n</insert>\n```\n\n## 动态修改-多个条件有的修改有的不修改\n\n用set if标签\n\n```xml\n<update id=\"update\">\n    update tb_brand\n    <set>\n        <if test=\"brandName!=null and brandName!=''\">\n            brand_name=#{brandName}\n        </if>\n        <if test=\"companyName!=null and companyName!='' \">\n            company_name=#{companyName}\n        </if>\n        <if test=\"ordered!=null\">\n            ordered=#{ordered}\n        </if>\n        <if test=\"description!=null and description!='' \">\n            description=#{description}\n        </if>\n        <if test=\"status!=null\">\n            status=#{status}\n        </if>\n    </set>\n    where id=#{id}\n</update>\n```\n\n## 删除\n\n```xml\n<delete id=\"deleteById\" parameterType=\"int\">\n    delete from tb_brand where id=#{id};\n</delete>\n```\n\n## 批量删除\n\nMyBatis会将数组参数封装成一个Map集合，默认array，或者使用```@Param```注解改变map集合的默认key的名称\n\n```void deleteByIds(@Param(\"ids\")int[] ids);```\n\n```xml\n<delete id=\"deleteByIds\">\n    delete from tb_brand\n    where id in\n    <foreach collection=\"ids\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n        #{id}\n    </foreach>\n</delete>\n```\n\n## 参数传递\n\nMyBatis接口方法可以接受各种各样的参数\n\n单个参数：\n    POJO类型:直接使用,属性名与#{}占位符名称一致就可以使用\n\n    Map集合:直接使用键名与#{}名一致\n    Collection\n    List\n    Array\n    其他类型:\n\n多个参数:\n    用```@Param```注解\n\n多个参数封装成Map，值就是参数的值，键arg0...,param1...这种类型\n\nMyBatis提供了ParamNameResolver类来进行参数封装\n\narg0,param1这种可读性差，所以使用@Param进行注解，替换arg0...这些在Map中的键\n\n## 使用注解实现CURD\n\n@Select\n@Insert\n@Update\n@Delete\n\n注解完成简单功能，复杂功能通过.xml配置文件完成\n","categories":["其他"]},{"title":"146.LRU 缓存","url":"/2022/04/02/LeetCode刷题/146.LRU 缓存/","content":"\n# 146.LRU 缓存\n\n## 题目描述\n\n模拟一个cache的LRU(最近最少使用)的调度策略\n\n其中cache的容量是capacity\n\n## 解题思路\n\n其实体系结构操作系统课都学过LRU的原理，怎么用编程来实现呢？\n\n体系结构课给出的描述是：首先应该有一个栈，这个栈可以将一个元素给调到栈顶，然后还可以将超出容量的元素从另一端挤出去(应该是这样)\n\n实现方式：\n\n双向链表+Map\n\n双向链表的结点保存了一个value，然后在Map中可以根据key找到这个双向链表中的结点\n\n这样的话就是在头部插入元素，在尾部删除元素，将某一元素调整到头部三个操作\n","tags":["模拟"],"categories":["LeetCode刷题"]},{"title":"207.课程表","url":"/2022/04/01/LeetCode刷题/207.课程表/","content":"\n# 207.课程表\n\n## 题目描述\n\n就是一共有numCourses门课，然后有一些先修课程的要求，判断能够完成所有的课程学习\n\n## 解题思路\n\n其实一共有numCourses个结点，然后先修课程的关系构成一张图\n\n先修课程对[0,1]表示：想要学习课程0，你需要先完成课程1，也就是有一个结点1指向0的边\n\n判断这个图中是否存在圈\n\n每个节点有三个状态\n\n1. 未搜索：还没有搜索到这个节点\n\n2. 搜索中：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；\n\n3. 已完成：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。\n\n当深度优先搜索搜索到搜索中状态的结点的时候说明该图存在环，就有了循环依赖\n","tags":["图"],"categories":["LeetCode刷题"]},{"title":"221.最大正方形","url":"/2022/04/01/LeetCode刷题/221.最大正方形/","content":"\n# 221.最大正方形\n\n## 题目描述\n\n在一个由'0'和'1'组成的二维矩阵内，找到只包含'1'的最大正方形，并返回其面积\n\n## 解题思路\n\ndp[i][j]表示右下角是i,j格的最大正方形边长\n\n```java\nfor (int i = 0; i < matrix.length; i++) {\n    for (int j = 0; j < matrix[0].length; j++) {\n        if (matrix[i][j] == '1') {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n            ans = Math.max(ans, dp[i][j]);\n        }\n    }\n}\n```\n\n不断更新的同时记录最大边长，最后返回最大边长的平方即可\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"954.二倍数对数组","url":"/2022/04/01/LeetCode刷题/954.二倍数对数组/","content":"\n# 954.二倍数对数组\n\n## 题目描述\n\n给定一个长度为偶数的整数数组arr，只有对arr进行重组后arr[2*i+1]=2*arr[2*i]时，返回true；否则，返回false\n\n## 解题思路\n\n肯定要先排序，然后记录每个元素的个数\n\n直接用TreeSet就可以了，TreeMap会将key排序，并且记录每个数字的数量\n\n然后对key进行判断，key>0的话就是找key*2\n\nkey\\<0的话就是先判断key是否能被2整除，再找key/2\n\n每次匹配后都得把这些数减去相应的数量，当找不到匹配的数时就返回false，不然就是true\n","categories":["LeetCode刷题"]},{"title":"287.寻找重复数","url":"/2022/03/31/LeetCode刷题/287.寻找重复数/","content":"\n# 287.寻找重复数\n\n## 题目描述\n\n给定一个包含n+1个整数的数组nums，其数字都在[1,n]范围内（包括1和n），假设 nums 只有 一个重复的整数，返回这个重复的数。\n\n要求:不修改原数组,额外空间O(1),时间复杂度O(n)\n\n## 解题思路\n\n做一个i到nums[i]的映射\n\n如[1,3,4,2,2]就是0-->1-->3-->2-->4-->2\n将(i,nums[i])抽象成了一个链表,最后的4-->2就构成了一个环\n\n这个题就和[142.环形链表II](/2022/03/31/LeetCode刷题/142.环形链表II/index.html)一模一样了\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"200.岛屿数量","url":"/2022/03/31/LeetCode刷题/200.岛屿数量/","content":"\n# 200.岛屿数量\n\n## 题目描述\n\n给一个char[][]，0表示水，1表示陆地\n\n岛屿由陆地水平竖直方向相连，求岛屿的数量\n\n## 解题思路\n\n当碰到陆地时进行DFS，把这块陆地置为0\n\n然后就可以得到陆地的数量了\n","tags":["DFS"],"categories":["LeetCode刷题"]},{"title":"198.打家劫舍","url":"/2022/03/31/LeetCode刷题/198.打家劫舍/","content":"\n# 198.打家劫舍\n\n## 题目描述\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。\n如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n## 解题思路\n\ndp[i][0]表示不拿第i个屋，dp[i][1]表示拿第i个屋\n\n```java\ndp[0][1] = nums[0];\nfor (int i = 1; i < nums.length; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\n    dp[i][1] = dp[i - 1][0] + nums[i];\n}\nreturn Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);\n```\n\n不偷i屋，那么dp[i][0]应该是偷或者不偷i-1屋的最大值\n\n偷i屋，那么dp[i][1]应该是不偷i-1屋的值+该屋的值\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"142.环形链表II","url":"/2022/03/31/LeetCode刷题/142.环形链表II/","content":"\n# 142.环形链表II\n\n## 题目描述\n\n给定一个链表的头节点head，返回链表开始入环的第一个节点。如果链表无环，则返回null。\n\n## 解题思路\n\n[141.环形链表](/2022/03/22/LeetCode刷题/141.环形链表/index.html)是判断链表是否存在环，该题是找到环的入口\n\n如果不存在环，那么快指针一定会走到null\n\n如果存在环，设链表的左侧非环长度是m，环形长度是c\n\n快指针走了2n个结点，慢指针走了n个结点，那么慢指针就在环内走了n-m个结点\n\n让慢指针再在环内走m个结点那么他就来到了环的起始位置，这样的话可以另取一指针指向头部，这个指针走过m个结点时正好和慢指针在环的起始位置相遇，作为答案返回即可\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"1606.找到处理最多请求的服务器","url":"/2022/03/30/LeetCode刷题/1606.找到处理最多请求的服务器/","content":"\n# 1606.找到处理最多请求的服务器\n\n## 题目描述\n\nk个服务器，一个服务器同一时间只能处理一个请求\n\n一个arrive[]请求到达时间数组，一个load[]请求工作时间数组\n\n第i个请求优先分配给第i%k个服务器，如果该服务器繁忙则继续查找下一个服务器，这些服务器视作一个环\n\n返回最繁忙的服务器列表\n\n## 解题思路\n\n用一个数组记录每个服务器的执行任务的数量\n\n用一个TreeSet来记录可用的服务器isAvailable\n\n用一个优先队列isBusy记录任务完成时间以及这个服务器序号，按完成时间升序排序\n\n开始模拟任务达到的过程\n\n    1. 记录到达时间\n    2. 如果有已经执行完任务的服务器将他从isBusy中弹出并且加入到isAvailable中去\n    3. 如果isAvailable为空这个任务执行不了\n    4. 否则按规则找到可以执行的服务器\n    5. 更新isAvailable和isBusy\n\n最后遍历每个服务器执行任务的数量并得出答案\n","tags":["模拟"],"categories":["LeetCode刷题"]},{"title":"236.二叉树的最近公共祖先","url":"/2022/03/30/LeetCode刷题/236.二叉树的最近公共祖先/","content":"\n# 236.二叉树的最近公共祖先\n\n## 题目描述\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先\n\n一个节点也可以是它自己的祖先\n\n## 解题思路\n\n这个题大二小学期好像碰到过类似的，当时感觉老难了，现在竟然一下写出来了\n\n用一个Map记录每个节点的父节点，一遍DFS完成Map的构建\n\n然后记录一个结点的父节点的路径，用Set记录即可\n\n然后查找另一个结点的父节点路径，并判断是否出现在Set中，第一次出现在Set中的就是最近公共祖先\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"139.单词拆分","url":"/2022/03/29/LeetCode刷题/139.单词拆分/","content":"\n# 139.单词拆分\n\n## 题目描述\n\n给你一个字符串s和一个字符串列表wordDict作为字典\n\n判断是否可以利用字典中出现的单词拼接出s\n\n不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用\n\n## 解题思路\n\n我想到的是DFS，碰到了个什么s是\"aaaaaaaaa···\",wordDict是[\"a\",\"aa\",···]的用例超时了，觉得确实有问题，发现自己好容易吧dp题想成DFS(自闭.jpg\n\n<hr>\n\ndp[i]表示字符串s前i个字符是否能被空格拆分成若干个字典中出现的单词\n\n为了方便查找字典，先将字典的单词保存到了一个Set中去\n\n```java\ndp[0] = true;\nfor (int i = 1; i <= s.length(); i++) {\n    for (int j = 0; j < i; j++) {\n        //substring(i,j),[i,j)包左不包右\n        if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n            dp[i] = true;\n            break;\n        }\n    }\n}\n```\n\n如果dp[j]也就是前j个字符可以被拆分，并且词典中包括s[j,i)的字符串，那么前i个字符也可以被拆分\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"279.完全平方数","url":"/2022/03/29/LeetCode刷题/279.完全平方数/","content":"\n# 279.完全平方数\n\n## 题目描述\n\n给一个整数n，返回和为n的完全平方数的最少数量\n\neg:12=4+4+4 ans=3\n\n## 解题思路\n\ndp[i]表示整数i所需要的最少完全平方数的数量\n\n```java\nint min = Integer.MAX_VALUE;\nfor (int j = 1; sqrt[j] <= i; j++) {\n    //我也想到了dp[i-j*j]\n    min = Math.min(min, dp[i - sqrt[j]]);\n}\ndp[i] = min + 1;\n```\n\nj从1开始一直到j*j\\<=i,这样的话第一次min就会更新成dp[i-1]，如果j*j=i就会更新为dp[0]\n\n然后最后进行+1操作即可，因为总归会一个完全平方数哪怕是1，当然也有可能是更大的\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"mysql基础","url":"/2022/03/29/其他/mysql基础/","content":"\n# mysql基础\n\nMySQL使用三值逻辑——TRUE,FALSE和UNKNOWN。任何与 NULL值进行的比较都会与第三种值UNKNOWN做比较。这个“任何值”包括NULL本身！\n\n这就是为什么MySQL提供IS NULL和IS NOT NULL两种操作来对NULL特殊判断。\n\n<hr>\n\n查询表只想取最大，最小值或最大的n个值时可以先排序，然后使用limit\n","categories":["其他"]},{"title":"2024.考试的最大困扰度","url":"/2022/03/29/LeetCode刷题/2024.考试的最大困扰度/","content":"\n# 2024.考试的最大困扰度\n\n## 题目描述\n\n一个由T和F组成的字符串，最大化连续相同的字符，可以将一个字符修改为T或F，最多修改k次\n\n## 解题思路\n\n两个指针left和right记录[left right]内T和F的数量\n\nleft和right都等于0，将right右移遍历整个字符串\n\n如果T,F数量中的最小值比k大了，说明以及无法修改了，将left左移，然后修改移动后的[left right]的数量，直到满足T,F数量中的最小值等于k\n\n然后每次循环中都维护[left,right]的最大长度\n\n```Java\nwhile (Math.min(tCnt, fCnt) > k) {\n    if (answerKey.charAt(left) == 'T') {\n        tCnt--;\n    } else {\n        fCnt--;\n    }\n    left++;\n}\n```\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"128.最长连续序列","url":"/2022/03/28/LeetCode刷题/128.最长连续序列/","content":"\n# 128.最长连续序列\n\n## 题目描述\n\n给定一个未排序的整数数组nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\neg:\n\n```text\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n## 解题思路\n\n题目要求时间复杂度为O(n)，所以排序O(nlong)肯定不行了,同样暴力的查找$O(n^2)$肯定也不行\n\n1. Set\n\n    集合存所有数字，遍历集合\n\n    ```java\n    int cur = num;\n    if (!set.contains(cur - 1)) {\n        while (set.contains(cur + 1)) {\n            cur++;\n        }\n    }\n    ```\n\n    只有当num-1不存在时，才开始向后遍历，这样时间复杂度就是O(n)\n\n2. Map\n\n    // key表示num，value表示num最远到达的连续右边界\n\n    ```java\n    if (map.containsKey(nums[i])) {\n        int right = map.get(nums[i]);\n        while (map.containsKey(right + 1)) {\n            map.remove(right);\n            right = map.get(right + 1);\n        }\n        map.put(nums[i], right);\n        ans = Math.max(ans, right - nums[i] + 1);\n    }\n    ```\n\n    每次while循环中把遍历到的right键值对删除，只通过最后一步put保留这次循环中最小元素到最大元素的键值对。这样后续元素才可以因为map中没有相应的key提前退出循环，达到减少遍历次数的效果。\n","tags":["Set","Map"],"categories":["LeetCode刷题"]},{"title":"332.零钱兑换","url":"/2022/03/28/LeetCode刷题/332.零钱兑换/","content":"\n# 332.零钱兑换\n\n## 题目描述\n\n给一个数组coins里面的值是不同面额的硬币，每个硬币的数量是无限的\n\n给一个amount，求总金额为amount需要最少多少硬币数\n\n## 解题思路\n\n我: dp[i][j]表示在前i种硬币中拿总额为j的硬币，需要多少硬币\n\n题解：dp[i]表示拿总额为i的硬币需要多少个硬币\n\n其实两种是一样，需要的遍历次数也是一样的，都是O(mn)，但我好容易把一维能解决的dp想成二维的（捂脸.jpg\n\n```Java\nfor (int i = 1; i <= amount; i++) {\n    for (int j = 0; j < coins.length; j++) {\n        if (coins[j] <= i) {\n            dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);//拿第j枚硬币\n        }\n    }\n}\n```\n\n因为是从小到大遍历的，所以不需要考虑拿多枚的情况，只要维护住dp[i]的最小值就可以\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"114.二叉树展开为链表","url":"/2022/03/28/LeetCode刷题/114.二叉树展开为链表/","content":"\n# 114.二叉树展开为链表\n\n## 题目描述\n\n将二叉树按先序遍历的顺序展开为链表，链表用左子树为空的数的形式表示\n\n## 解题思路\n\n先将左子树右子树互换位置，然后递归的对左右子树进行展开，然后找到当前的最右结点，将左子树接到最右结点的右子树上去，同时将左子树置为null\n\n当根节点为空或左子树右子树都为空时return\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"105.从前序与中序遍历序列构造二叉树","url":"/2022/03/28/LeetCode刷题/105.从前序与中序遍历序列构造二叉树/","content":"\n# 105.从前序与中序遍历序列构造二叉树\n\n## 题目描述\n\n给先序遍历和中序遍历的数组，还原二叉树\n\n## 解题思路\n\n先序遍历的第一个是根节点，在中序中找到这个数然后中序遍历的左侧是左子树，右侧是右子树\n\n递归的构建树，当序列长度是0的时候返回null，当序列长度是一的时候构建叶子结点\n\n我用了Array.copyOfRang来对先序和中序序列求子区间，这个程序的执行用时和内存消耗有点高，原因是Arrays.copyOfRang的复制过程,可以使用四个数来标记区间来降低\n","tags":["树"],"categories":["LeetCode刷题"]},{"title":"字符集","url":"/2022/03/27/Java基础/字符集/","content":"\n# 字符集\n\nJava的char占两个字符\n\nGBK中文占2字节\n\nUTF-8中文占3字节\n","categories":["Java基础"]},{"title":"98.验证二叉搜索树","url":"/2022/03/27/LeetCode刷题/98.验证二叉搜索树/","content":"\n# 98.验证二叉搜索树\n\n## 题目描述\n\n判断一个二叉树是否为二叉搜索树\n\n## 解题思路\n\n我要被自己蠢死了（wuwuwu\n\n还是对二叉搜索树的理解不深，每一个结点值都有一个上下界，找左子树时更新上界，找右子树时更新下界\n\n下面是官方题解的代码\n\n```Java\npublic boolean isValidBST(TreeNode root) {\n    return DFS(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n\npublic boolean DFS(TreeNode root, long lower, long upper) {\n    if (root == null) {\n        return true;\n    }\n    if (root.val <= lower || root.val >= upper) {\n        return false;\n    }\n    return DFS(root.left, lower, root.val) && DFS(root.right, root.val, upper);\n}\n```","tags":["DFS"],"categories":["LeetCode刷题"]},{"title":"96.不同的二叉搜索树","url":"/2022/03/27/LeetCode刷题/96.不同的二叉搜索树/","content":"\n# 96.不同的二叉搜索树\n\n## 题目描述\n\n求由n个节点组成且节点值从1到n互不相同的二叉搜索树 有多少种\n\n## 解题思路\n\n很容易发现n=1是有1种，n=2时有两种\n\n然后考虑到将1-n分别作为根节点，左侧和右侧的结点数可以求出\n\n```Java\nfor (int i = 3; i <= n; i++) {\n    for (int j = 1; j <= i; j++) {\n        int left = j - 1;\n        int right = i - j;\n        if (left != 0 && right != 0) {\n            ans[i] += (ans[left] * ans[right]);\n        } else {\n            ans[i] += (ans[left] + ans[right]);\n        }\n    }\n}\n```\n\n然后求到第n个结点有多少种返回即可\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"5253.找到指定长度的回文数","url":"/2022/03/27/LeetCode刷题/5253.找到指定长度的回文数/","content":"\n# 5253.找到指定长度的回文数\n\n## 题目描述\n\n长度为intLength的回文数，求第queries个\n\n## 解题思路\n\n找回文数的规律，以长度为5为例\n\n10001\n10101\n10201\n...\n10901\n11011\n...\n11111\n11211\n...\n11911\n12021\n...\n99999\n\n前半部分是从100-999，这样就可以找到回文数的个数\n\n```Java\nif ((long) q > (long) 9 * Math.pow(10, (intLength - 1) / 2)) {\n    ans[i] = -1;\n    continue;\n}\n```\n\n然后通过StringBuilder的reverse和substring对他进行翻转拼接\n","categories":["LeetCode刷题"]},{"title":"5269.从栈中取出K个硬币的最大面值和","url":"/2022/03/27/LeetCode刷题/5269.从栈中取出 K 个硬币的最大面值和/","content":"\n# 5269.从栈中取出 K 个硬币的最大面值和\n\n## 题目描述\n\n有n个栈，里面放置着一些硬币，取出k枚，求k枚硬币的最大和\n\n## 解题思路\n\n因为是栈，贪心肯定不行\n\n用DFS写了一遍，时间复杂度应该是$O(2^n)$,TLE了\n\n然后想到用dp，但是只想到dp[i][j]表示计算到第i个栈时取j个时的最大值\n\n后来看了眼题解题解的dp[i]表示取i个硬币时的最大值，按我的理解还是写出dp[i][j]的形式\n\n```Java\nint[][] dp = new int[piles.size() + 1][k + 1];//dp[i]表示取i个硬币时的最大值\nfor (int index = 1; index <= piles.size(); index++) {\n    List<Integer> pile = piles.get(index - 1);\n    for (int i = 1; i <= k; i++) {\n        dp[index][i] = dp[index - 1][i];\n        for (int j = 1; j <= i && j <= pile.size(); j++) {\n            dp[index][i] = Math.max(dp[index][i], dp[index - 1][i - j] + pile.get(j - 1));\n        }\n    }\n}\nreturn dp[piles.size()][k];\n```\n\n需要对使用j分割开，表示在index这个栈中取j个硬币\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"79.单词搜索","url":"/2022/03/26/LeetCode刷题/79.单词搜索/","content":"\n# 79.单词搜索\n\n## 题目描述\n\n一个二维字符数组，一个单词，水平或垂直相邻的，并且每个单元格内的字母不允许重复使用\n\n## 解题思路\n\nDFS\n\n找到首字符相同的，然后找到他的四个方向的字符，判断是否和当前index相同，相同就DFS\n\n找四个方向的时候别忘了判断坐标的合法性\n\n同时用visit[][]标记该单元格是否已经被使用，使用过的不能继续使用了\n","tags":["DFS"],"categories":["LeetCode刷题"]},{"title":"78.子集","url":"/2022/03/25/LeetCode刷题/78.子集/","content":"\n# 78.子集\n\n## 题目描述\n\n一个数组nums，返回他的所有子集，子集不能重复\n\n## 解题思路\n\n（为什么我写的DFS这么垃圾！！！，O(n!)-->TLE\n\n其实就是$O(2^n)$,每个二进制位标记当前这个数字是否选择\n\n```Java\ntemp.add(nums[length]);\nDFS(length + 1, nums, temp);//选\ntemp.remove(temp.size() - 1);\nDFS(length + 1, nums, temp);//不选\n```\n\n[46.全排列](/2022/03/24/LeetCode刷题/46.全排列/index.html)\n","tags":["DFS"],"categories":["LeetCode刷题"]},{"title":"75.颜色分类","url":"/2022/03/25/LeetCode刷题/75.颜色分类/","content":"\n# 75.颜色分类\n\n## 题目描述\n\n一个数组里面全是乱序的0，1，2,按从小到大排序\n\n## 解题思路\n\nindex0指向头部，index2指向尾部，然后根据0和2进行判断进行swap\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"62.不同路径","url":"/2022/03/25/LeetCode刷题/62.不同路径/","content":"\n# 62.不同路径\n\n## 题目描述\n\n一个m*n的地图，从左上走到右下，并且只能向下或向右移动一步，问多少种路径\n\n## 解题思路\n\n```Java\nfor (int i = 1; i < n; i++) {\n    for (int j = 1; j < m; j++) {\n        dp[j][i] = dp[j - 1][i] + dp[j][i - 1];\n    }\n}\n```\n\n[64.最小路径和](/2022/03/24/LeetCode刷题/64.最小路径和/index.html)\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"55.跳跃游戏","url":"/2022/03/25/LeetCode刷题/55.跳跃游戏/","content":"\n# 55.跳跃游戏\n\n## 题目描述\n\n给定一个非负整数数组nums你最初位于数组的第一个下标\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标\n\n## 解题思路\n\n贪心\n\n```int[] nums = new int[]{4, 2, 0, 0, 1, 1, 4, 4, 4, 0, 4, 0};```\n\n这个例子很好的说明了贪心max=i+j+nums[i+j]\n\n//max应该指当前所能到达的最远的值，而不是当前所能跳的这些格子的最大值\n\n//max=num[i+j]只考虑到往i+j跳之后还能再跳多少，没用考虑到跳到i+j已经跳了多少（自己写的错在这里了）\n","tags":["贪心"],"categories":["LeetCode刷题"]},{"title":"49.字母异位词分组","url":"/2022/03/25/LeetCode刷题/49.字母异位词分组/","content":"\n# 49.字母异位词分组\n\n## 题目描述\n\n一个字符串数组，将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母恰好只用一次。\n\n## 解题思路\n\n使用map记录每一个字符串中字母及其出现的次数\n\n遍历字符串数组，向后找和他相同的map，这样他们就是一组的\n\n为了减少循环次数，可以使用visited[]标记字符串是否已经被分组了，这也对比次数由$O(n^2)$退化为$O(n)$\n","categories":["LeetCode刷题"]},{"title":"48.旋转图像","url":"/2022/03/25/LeetCode刷题/48.旋转图像/","content":"\n# 48.旋转图像\n\n## 题目描述\n\n将一个矩阵旋转90度，必须原地修改\n\n## 解题思路\n\n将整个图像视为一圈一圈的，针对每一圈\n\n对这一圈的每一个元素进行旋转，因为是正方形，一共有四个位置相关，找到这四个元素的位置关系即可\n\n```Java\nx = y;\ny = size - 1 - x;\n```\n","categories":["LeetCode刷题"]},{"title":"172.阶乘后的零","url":"/2022/03/25/LeetCode刷题/172.阶乘后的零/","content":"\n# 172.阶乘后的零\n\n## 题目描述\n\n返回n!结果中尾随零的数量\n\n## 解题思路\n\n肯定不会真的去算阶乘\n\n1. 求出因子2和5的个数，然后返回较小的\n\n2. 因为因子2的个数肯定比因子5的个数多，所以直接求因子5的个数返回即可\n\n3. 相较于从1~n的遍历，直接将因子5的个数加n/5，然后所有n/5不断循环至n=0即可\n","categories":["LeetCode刷题"]},{"title":"661.图片平滑器","url":"/2022/03/24/LeetCode刷题/661.图片平滑器/","content":"\n# 661.图片平滑器\n\n## 题目描述\n\n就是求卷积\n\n## 解题思路\n\n1. 直接遍历\n\n2. 优化\n\n    前缀和\n\n    sum[i][j]表示当前区域的和\n\n    {%asset_img 661.show.png 前缀和 %}\n","categories":["LeetCode刷题"]},{"title":"一些不常用操作","url":"/2022/03/24/Java基础/一些不常用操作/","content":"\n将`List<Integer>`转换为`int[]`\n\n`ans.stream().mapToInt(Integer::valueOf).toArray()`\n\n`ans`是`List<Integer>`类型\n\n<hr>\n\n```Arrays.copyofRange```包括左面，不包括右面[from,to)\n\n<hr>\n\nint数组变成Integer数组\n\n```Integer[] temp = Arrays.stream(coins).boxed().toArray(Integer[]::new);```（coins是int[]）\n\n<hr>\n\n字符串的substring(i,j)方法也是包括i不包括j的\n\n<hr>\n\nHashSet不能保证元素的排列顺序\n\nTreeSet可以按自定义规则自动排序\n\n    ceiling()方法用于返回等于或大于给定元素(ele)的最低元素(如果存在)，否则返回null。\n\n<hr>\n\n```String CDATA_CONTENT_PATTERN = \"<!\\\\[CDATA\\\\[.*?]]>\";```\n\n虽然说正则表达式匹配[需要在[前加\\转义，但是在java字符串中\\本身就需要加\\转义，所以在用字符串表示正则表达式时需要加两个\\\n\nString.replaceAll将所有匹配项全部替换\n\nString.replaceFirst替换第一个匹配到的\n\n试了一下replaceAll如果先匹配到的替换成了字符串能够使前面的成果匹配，也是可以再给replace的，不是一遍遍历(一遍遍历是错误的)\n\n<hr>\n\n```List<String>```变成```String[]```\n\n```java\nList<String> log2 = new ArrayList<>();\nlog2.toArray(new String[0]);\n```\n\n<hr>\n\n标签\n\n```java\nout:\nfor (int i = 0; i < 4; i++) {\n    for (int j = 0; j < i; j++) {\n        if (cur[j] == cur[i]) continue out;\n    }\n```\n\ncontinue可以直接跳转到最外层for循环\n\n<hr>\n\n<<<无符号左移\n\n\\>\\>\\>无符号右移","categories":["Java基础"]},{"title":"64.最小路径和","url":"/2022/03/24/LeetCode刷题/64.最小路径和/","content":"\n# 64.最小路径和\n\n## 题目描述\n\n一个二维数组，从左上角走到右下角的距离，只能向下或向右走\n\n## 解题思路\n\ndp题\n\ndp[i][j]是走到当前的对短距离，构建好dp[][]即可\n\n```Java\nfor (int i = 1; i <= n; i++) {\n    dp[1][i] = dp[1][i - 1] + grid[0][i - 1];\n}\nfor (int i = 1; i <= m; i++) {\n    dp[i][1] = dp[i - 1][1] + grid[i - 1][0];\n}\nfor (int i = 2; i <= m; i++) {\n    for (int j = 2; j <= n; j++) {\n        dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i - 1][j - 1];\n    }\n}\nreturn dp[m][n];\n```\n","tags":["dp"],"categories":["LeetCode刷题"]},{"title":"46.全排列","url":"/2022/03/24/LeetCode刷题/46.全排列/","content":"\n# 46.全排列\n\n## 题目描述\n\n给定一个不含重复数字的数组nums，返回其所有可能的全排列。可以按任意顺序返回答案\n\n## 思路描述\n\n今天写过[39.组合总和](/2022/03/24/LeetCode刷题/39.组合总和/index.html)了，所以这道题写的很快（开心\n\n```Java\npublic void DFS(List<Integer> list, int length, List<Integer> temp) {\n    if (length == len) {\n        ans.add(new ArrayList<>(temp));\n        return;\n    }\n    for (int i = 0; i < list.size(); i++) {\n        int num1 = list.remove(i);\n        temp.add(num1);\n        DFS(list, length + 1, temp);\n        int num2 = temp.remove(length);\n        list.add(i, num2);\n    }\n}\n```\n\nlength是当前排列的长度，当他长度是nums的长度是插入到ans中，不然的话就继续DFS\n","categories":["LeetCode刷题"]},{"title":"39.组合总和","url":"/2022/03/24/LeetCode刷题/39.组合总和/","content":"\n# 39.组合总和\n\n## 题目描述\n\n一个无重复元素的整数数组candidates和一个目标整数target，找出candidates中可以使数字和为目标数target的所有不同组合，并以列表形式返回\n\ncandidates中的同一个数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的\n\n## 解题思路\n\n简单的DFS，好久没用过已经快忘了\n\n先给candidates排序\n\n```Java\npublic void dfs(int[] candidates, int target, List<Integer> temp, int idx) {\n    if (idx == candidates.length) {\n        return;\n    }\n    if (target == 0) {\n        ans.add(new ArrayList<>(temp));\n        return;\n    }\n    dfs(candidates, target, temp, idx + 1);\n    if (target - candidates[idx] >= 0) {\n        temp.add(candidates[idx]);\n        dfs(candidates, target - candidates[idx], temp, idx);\n        temp.remove(temp.size() - 1);\n    }\n}\n``` \n\nDFS题目[46.全排序](/2022/03/14/LeetCode刷题/46.全排列/index.html)\n","categories":["LeetCode刷题"]},{"title":"MyBatis入门","url":"/2022/03/23/JavaWeb/MyBatis入门/","content":"\n# MyBatis入门\n\n使用maven管理项目,加入依赖\n\n```xml\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.9</version>\n</dependency>\n```\n\n```mybatis-config.xml```配置文件在```resources```文件夹下\n\n其中会配置一些数据库登录信息\n\n```xml\n<dataSource type=\"POOLED\">\n    <!--数据库连接信息-->\n    <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\"/>\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"123456\"/>\n</dataSource>\n```\n\nurl中可以配置serverTimezone=UTC\n有时报错可以删去useSSL=false\n\n同时也会配置一些mapper映射文件信息\n\n使用idea在resources文件下下创建mapper文件夹时注意不要创建成用```.```分割的名称，不然会认为这整个字符串是文件夹名，应该用```/```来分割\n\n但是在idea中又会显示成```.```分割的形式，所以要注意配置```mybatis-config.xml```时```<mapper resource=\"com/heima/mapper/UserMapper.xml\"/>```的路径应用```/```表示\n\n## 以包的形式加载所有的mapper(Mapper代理方式)\n\n类似于```<package name=\"com/heima/mapper\"/>```，将所有的XXXMapper.xml放入到mapper文件夹(包中)\n\n免去多个mapper的需要写多次映射的麻烦\n\n在代码文件夹创建mapper存放接口，resources文件夹创建mapper存放.xml,可以更方便的调用\n\nmaven会自动配置Mapper.xml与Mapper.class，\n\n```Java\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nList<User> users = userMapper.selectAll();\n```\n\n```Java\nSqlSession sqlSession = sqlSessionFactory.openSession();\nList<User> users = sqlSession.selectList(\"UserMapper.selectAll\");\n```\n\n<hr>\n\nPublic Key Retrieval is not allowed\n\n在连接url后加```allowPublicKeyRetrieval=true```\n\n<br>\n\n```Could not retrieve transation read-only status server```的解决办法\n\n使用MySql数据库服务为最新版本8.0.11，而在项目开发的过程中使用了低版本的MySql驱动包\n","categories":["其他"]},{"title":"234.回文链表","url":"/2022/03/23/LeetCode刷题/234.回文链表/","content":"\n# 234.回文链表\n\n## 题目描述\n\n判断一个链表是否回文1221\n\n## 解题思路\n\n显然如果是数组就很好判断了,但是为了实现空间复杂度O(1)不能将其转换为数组\n\n**快慢指针**:一个走一步一个走两步,可以找到链表的中点,然后将链表反转,就可以判断是否回文了\n\n最近碰到好几个快慢指针的题了,如判断链表是否有环,之前听都没听过\n","categories":["LeetCode刷题"]},{"title":"440.字典序的第K小数字","url":"/2022/03/23/LeetCode刷题/440.字典序的第K小数字/","content":"\n# 440.字典序的第K小数字\n\n## 题目描述\n\n给定n,k，返回[1,n]中字典序第k小的数组\n\n## 思路\n\n$1 <= k <= n <= 10^9$\n\n**一定要用long**,不然会溢出导致结果错误\n\n1. 类似于[386.字典序排数](/2022/03/19/LeetCode刷题/386.字典序排数/index.html)，使用一个字典树保存各个数字，然后再先序遍历，但是针对本题的数据量建立字典树内存不够\n\n2. 然后写了个O(n)的算法\n\n    ```Java\n    public void solve(long base) {\n        for (int i = 0; i <= 9; i++) {\n            long temp = base + i;\n            if (temp > n) {\n                return;\n            }\n            id++;\n            if (id == k) {\n                ans = (int) temp;\n                return;\n            } else if (id < k) {\n                solve(temp * 10);\n            } else {\n                return;\n            }\n        }\n    }\n    ```\n\n    其实也是想按字典树来写的，也不怎么就写成了个O(n)的，同时因为用了int导致d了好长时间bug，最后发现是long的问题，改成long后答案正确但是会TLE\n\n3. 模拟字典树\n\n   首先应计算子树共有多少结点\n\n   {%asset_img 440.count.png 记录结点个数 %}\n\n    ```Java\n    public int count(long lower, long upper, long n) {\n        int num = 0;\n        while (lower <= n) {\n            num += Math.min(n + 1, upper) - lower;\n            lower *= 10;\n            upper *= 10;\n        }\n        return num;\n    }\n    ```\n\n    然后根据子树结点的个数来判断下一步操作，是右移还是下移\n\n    ```Java\n    public int findKthNumber(int n, int k) {\n        int ans = 1;\n        while (k > 1) {\n            int count = count(ans, ans + 1, n);\n            if (count < k) {\n                ans++;\n                k -= count;\n            } else {\n                ans *= 10;\n                k--;\n            }\n        }\n        return ans;\n    }\n    ```\n\n    通过不断地右移下移就可以找到第k个数字\n","categories":["LeetCode刷题"]},{"title":"mysql安装与配置","url":"/2022/03/22/其他/mysql安装与配置/","content":"\n# MySQL安装与配置\n\n## MySQL安装\n\n### Windows\n\n1. 下载官网的.zip包,将其解压到一个路径\n\n2. 去bin文件夹下执行```mysqld --install```\n\n3. 执行```mysqld --initialize --console```会生成一个密码\n\n4. 启动mysql服务```net start MySQL```\n\n5. 登录数据库```mysql -u root -p```,密码就是上面生成的随机密码\n\n6. 修改密码```alter user 'root'@'localhost' identified by '123456';```(记得```use mysql```选择数据)\n\n**记得将**`mysql\\bin`**放入到环境变量中去**\n\n这种安装和直接的.msi安装相比可以自定义安装目录，并且connector也不是预置的，使用时需要额外的下载\n\n`services.msc`可以启动服务\n\n### linux\n\n1. 访问```https://dev.mysql.com/downloads/repo/apt/```获取配置包下载地址\n\n2. ```wget https://dev.mysql.com/get/mysql-apt-config_0.8.14-1_all.deb```下载MySQL APT配置包\n\n3. ```sudo dpkg -i mysql-apt-config_0.8.14-1_all.deb```\n\n4. ```sudo apt-get update```\n\n5. ```sudo apt-get install mysql-server```安装mysql\n\n通过以上的APT方式安装好之后，所有的服务、环境变量都会启动和配置好，无须手动配置\n\n#### 服务管理\n\n查看服务状态```sudo service mysql status```\n\n停止服务```sudo service mysql stop```\n\n启动服务```sudo service mysql start```\n\n重启服务```sudo service mysql restart```\n\n#### 相关目录\n\n数据库目录：```/var/lib/mysql/```\n\n配置文件：```/etc/mysql```(如my.cnf)\n\n相关命令：```/usr/bin```(mysqladmin、mysqldump等命令)\n\n启动脚本：```/etc/init.d/mysql```\n\n####  卸载\n\n```sudo apt purge mysql-*```\n```sudo rm -rf /etc/mysql/ /var/lib/mysql```\n```sudo apt autoremove```\n```sudo apt autoclean```\n\n## MySQL配置\n\n### my.ini的配置\n\nwindows下和linux下配置文件名称不一样，一个叫my.ini一个叫my.cnf\n\n```ini\n[mysqld]\nport=3306\nbasedir=D:\\Software\\MySQL\ndatadir=D:\\Software\\MySQL\\data\nmax_connections=200\nmax_connect_errors=10\ncharacter-set-server=utf8\ndefault-storage-engine=INNODB\n\nlog-output=FILE\ngeneral-log=1\ngeneral_log_file=\"D:\\Software\\MySQL\\mysql.log\"\nslow-query-log=1\nslow-query_log_file=\"D:\\Software\\MySQL\\mysql_slow.log\"\nlong_query_time=2\n\n[mysql]\ndefault-character-set=utf8\n[client]\nport=3306\ndefault-character-set=utf8\n```\n\n### 远程访问权限\n\n创建能够远程访问的用户```create user 'root'@'%' identified by \"你的密码\";```\n\n授权```grant all privileges on *.* to 'root'@'%';```\n\n刷新```flush privileges;```\n\n修改```mysqld.cnf```配置文件，将**bind-address**修改为**0.0.0.0**\n\n重启mysql服务，就可以拿datagrip连接啦\n\n## 区分大小写\n\nmysql默认配置是表明区分大小写的\n\n配置中增加\n\n```\n[mysqld]\nlower_case_table_names=1#(0表示区分大小写)\n```\n\n然后重启mysql\n\n如果还没创建数据库，就可以直接用了，现在已经不区分大小写了\n\n如果已经存在了数据库，需要将已有库中的表名全改成小写，否则还是不行\n\n只有全改成小写之后，以后查询语句中不论写大写还是小写，才能正常识别\n\n而windows下式不区分大小写\n\n很墨迹，学习mysql分片时使用mycat时候因为就开了一个虚拟机，一个虚拟机，一个云服务器，然后加上windwos下的mysql\n\n会出现奇奇怪怪的bug，还是直接在linux下使用mysql吧\n","categories":["其他"]},{"title":"338.比特位计数","url":"/2022/03/22/LeetCode刷题/338.比特位计数/","content":"\n# 338.比特位计数\n\n## 题目描述\n\n给一个整数n,求出0~n之间的每个数的二进制表示有多少个1\n\n## 解题思路\n\n一种迭代的思想\n\n{%asset_img 338.bits.png 迭代过程 %}\n\n从i=1到n进行遍历，这样的话找到最高位，然后之后就是(i-最高位表示的数)的二进制位数再+1就是i的二进制表示中1的数量\n\n求最高位:根据规律可以看出，i和i-1求与(&)的值是0的时候更新最高位，如1000,0111\n","categories":["LeetCode刷题"]},{"title":"169.多数元素","url":"/2022/03/22/LeetCode刷题/169.多数元素/","content":"\n# 169.多数元素\n\n## 题目描述\n\n一个大小为n的数组，一个元素出现了n/2次以上，找到这个数\n\n## 解题思路(Boyer-Moore投票算法)\n\n因为这个多数元素在数组中出现的次数大于n/2,n一定是出现次数最多并且多于一半的.\n\n多于一半才可以用这种算法，普通的众数不可以。\n\n官方代码如下：\n\n```Java\npublic int majorityElement(int[] nums) {\n    int count = 0;\n    int candidate = 0;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n","categories":["LeetCode刷题"]},{"title":"141.环形链表","url":"/2022/03/22/LeetCode刷题/141.环形链表/","content":"\n# 141.环形链表\n\n## 题目描述\n\n给定一个链表，判断链表中是否有环\n\n## 解题思路\n\n1.哈希表:将已经出现的结点放入哈希表中，判断是否出现过\n\n2.取巧，因为题目中说最大结点数是10000，所以执行10000次，如果结点还没等于null就说明存在换\n\n3.方法2的通用办法——快慢指针\n\n一个指针取next另一个指针取next.next，然后遍历，如果存在环一定会存在量指针相同的情况，不然就会遍历到尾部判断出不存在环\n","categories":["LeetCode刷题"]},{"title":"160.相交链表","url":"/2022/03/22/LeetCode刷题/160.相交链表/","content":"\n# 160.相交链表\n\n## 题目描述\n\n给定两个链表，判断两个链表是否相交\n\n## 解题思路\n\n1.用一个set保存结点，再判断集合中是否存在结点来判断相交\n\n2.双指针\n\n一个指针pa指向链表A，另一个指针pb指向链表B，假设链表A比链表B长\n\npb已经遍历完时pa还没有遍历完，令pb指向链表A的头部，然后继续遍历\n\n{%asset_img 160.process.png 示意图 %}\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"Hexo的使用","url":"/2022/03/21/其他/hexo的使用/","content":"\n# Hexo的使用\n\n## 插入图片\n\n对配置文件进行修改\n\n```yml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n这样新建.md时会生成个文件夹，文件夹里放图片就行了\n\n**解决博客首页图片不显示的问题**：使用```{% asset_img example.jpg example %}```来插入图片\n\n## 支持数学公式\n\n[教程](https://github.com/next-theme/hexo-filter-mathjax)\n\nHexo的服务器端MathJax渲染器插件，不依赖任何前端脚本。\n\n```npm install hexo-filter-mathjax```\n\n对配置文件进行修改\n\n```yml\nmathjax :\n   tags : none # or 'ams' or 'all' \n  single_dollars : true #启用单个美元符号作为内联数学分隔符\n  cjk_width : 0.9  #相对 CJK 字符宽度\n  normal_width : 0.6  #相对正常（等宽）宽度\n  append_css : true #向 MathJax 渲染的页面添加 CSS \n  every_page : false #\n  如果为 true，则无论 Front-matter extension_options中的 `mathjax` 设置如何，每个页面都将由 MathJax 渲染：{}\n    #你可以把你的扩展选项放在这里\n    #更多细节参见 http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options\n```\n\n在每个markdown的开始位置设置\n\n```md\n---\nmathjax: true\n---\n```\n\n安装pandoc\n\n```npm install hexo-renderer-pandoc --save```\n\n```yml\npandoc:\n  pandoc_path: C:/Program Files/Pandoc/pandoc.exe\n```\n\n## 插入链接(相对路径)\n\n如[386.字典序排数](/2022/03/19/LeetCode刷题/386.字典序排数/index.html),相对路径以public为起始位置\n\n## 分类和标签的使用\n\n在```source```文件夹下创建```categories```和```tags```文件夹\n\n在下面创建```index.md```，插入下面的front-formatter就可以自动生成分类和标签了\n\n```md\n---\ntitle: categories\ndate: 2022-03-26 14:39:45\ntype: categories\n---\n```\n\n标签是同级的\n\n分类可以通过[category1,category2]来表示层级\n","categories":["其他"]},{"title":"283.移动零","url":"/2022/03/21/LeetCode刷题/283.移动零/","content":"\n# 283.移动零\n\n## 题目描述\n\n一个数组nums,将数组中所有的元素0移到末尾，并且保持其他元素的相对位置不变。\n\n## 解题思路\n\n{%asset_img 283.process.gif 示意图 %}\n\n用一个right标记第一个为0的位置，然后从right遍历整个数组，如果当前数组值不是0就将该值覆盖right位置，然后right++,最后将right及其后面的数组都赋值为0\n","categories":["LeetCode刷题"]},{"title":"121.买卖股票的最佳时期","url":"/2022/03/21/LeetCode刷题/121.买卖股票的最佳时期/","content":"\n# 121.买卖股票的最佳时期\n\n## 题目描述\n\n一个prices数组,prices[i]表示第i天的价格,在某一天买入，并且在未来的某个日子卖出，求最大利润，如果不能获得利润返回0;\n\n## 解题思路\n\n用一个minPrice标记到目前为止的最低价格，用ans表示当前能获得的最大利润。\n\n遍历prices如果price[i]比minPrice小，更新minPrice,不然判断当前能获得的利润(price-minPrice)如果比ans大，就更新ans\n\n2...11...1...8这种情况前面的已经记下来了9，后面虽然minPrice更新了，但是利润不会大过9\n\n","categories":["LeetCode刷题"]},{"title":"155.最小栈","url":"/2022/03/20/LeetCode刷题/155.最小栈/","content":"\n# 155.最小栈\n\n## 题目描述\n\n设计一个栈，能完成栈的常用操作，同时也能返回栈中的最小元素\n\n## 解题思路\n\n正常可能会想到这是一个最小堆，但是最小堆的插入和删除都会进行额外的排序\n\n因为栈的单侧进出的特点，使用额外的O(n)的空间来表示当前栈中最小的元素\n\n```Java\npublic void push(int val) {\n    if (size == 0) {\n        data[size] = val;\n        min[size] = val;\n    } else {\n        data[size] = val;\n        min[size] = Math.min(val, min[size - 1);\n    }\n    size++;\n}\n```\n","categories":["LeetCode刷题"]},{"title":"101.对称二叉树","url":"/2022/03/20/LeetCode刷题/101.对称二叉树/","content":"\n# 101.对称二叉树\n\n## 题目描述\n\n判断一个二叉树是否轴对称\n\n## 解题思路\n\n1.将二叉树序列化，存到一个数组中，再分别遍历二叉树的每一层，空结点的值用-1表示\n\n**不可行**,当二叉树很不规则是浪费空间\n\n2.双指针,p，q表示当前对称位置，不断的遍历，递归后即可完成判断\n\n```Java\npublic boolean isSymmetric(TreeNode root) {\n    return judge(root.left, root.right);\n}\n\npublic boolean judge(TreeNode p, TreeNode q) {\n    if (p == null && q == null) {\n        return true;\n    }\n    if (p == null) {\n        return false;\n    }\n    if (q == null) {\n        return false;\n    }\n    if (p.val != q.val) {\n        return false;\n    }\n    return judge(p.left, q.right) && judge(p.right, q.left);\n}\n```\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"136.只出现一次的数字","url":"/2022/03/20/LeetCode刷题/136.只出现一次的数字/","content":"\n# 136.只出现一次的数字\n\n## 题目描述\n\n一个非空数组，2m+1个数，其中一个数只出现一次，另外m个数出现2次\n\n## 思路\n\n1.用额外的O(n)的空间\n\n2.位运算——**妙啊**\n\na^a = 0;\na^0 = a;\n\n所以将整个数组做异或，最后的值就是ans\n","categories":["LeetCode刷题"]},{"title":"386.字典序排数","url":"/2022/03/19/LeetCode刷题/386.字典序排数/","content":"\n# 386.字典序排数\n\n## 题目描述\n\n将0~n范围内的数按字典序排列\n\n如1,10,11,12,13,2,3,4,5,6,7,8,9\n\n## 解题思路\n\n1.O(nlogn):按序生成1-n的list然后排序，然后返回\n\n2.建立一个字典树，然后前序遍历\n\n{%asset_img 386.tree.jpg 字典树 %}\n\n但是这样会使用O(n)的额外空间，所以在建树的过程中直接保存当前值即可，不保留树，这样就是题目要求的O(1)额外空间。\n","categories":["LeetCode刷题"]},{"title":"6021.字符串中最多数目的子字符串","url":"/2022/03/19/LeetCode刷题/6021.字符串中最多数目的子字符串/","content":"\n# 6021.字符串中最多数目的子字符串\n\n## 题目描述\n\n给一个字符串text和一个字符串pattern,pattern的长度是2,在text的任意位置插入pattern[0]或pattern[1],求插入后text中最多包含多少个等于pattern的子序列\n\n子序列指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。\n\n## 解题思路\n\n将pattern[0]插入到text的头部或将pattern[1]插入到pattern的尾部,然后进行判断即可。\n\nO(n)的解法,使用cnt记录pattern[0]出现的次数，当pattern[1]出现时，ans+=cnt;\n\n## 我超时的原因\n\n先遍历一遍text将其中的pattern[0]或pattern[1]字符拿出来\n\n然后在新的字符串中找pattern[0],然后再从该patter[0]的索引位置向后寻找patter[1]的数量,相当于o(n^2)的时间复杂度，所以超时了。\n\n思考:逆向思维，找pattern[1]同时记录之前出现过的pattern[0]的个数即可。","categories":["LeetCode刷题"]},{"title":"6022.将数组和减半的最少操作次数","url":"/2022/03/19/LeetCode刷题/6022.将数组和减半的最少操作次数/","content":"\n# 6022.将数组和减半的最少操作次数\n\n## 题目描述\n\n一个正整数组,每次操作可以选择一个数将他减小到一半,减小到一半的数依然在原数组可以继续操作，求最少操作多少次后可以使原数组和减半\n\n## 思路\n\n先排序,然后求和,然后每次都取最大的数进行减半,判断已减的和是否到达了原数组和的一半\n\n## 超时的原因及优化\n\n减半后的数我插入到了原数组中进行插入排序O(n^2),所以超时了。\n\n设置一个额外的数组保存已减半的数，令index2指向该数组中还未使用过的最大的数，length是该数组的长度\n\n{%asset_img 6022.extraArray.jpg 额外数组 %}\n\n每次比较原数组的当前最大数和index2指向的数，然后将减半的数放到这个数组的后面\n\n可以证明这个数组每次向尾部增加的元素总是小于前一个元素\n\n这样就通过O(n)的时间解决了，成功ac\n","categories":["LeetCode刷题"]},{"title":"720.词典中最长的单词","url":"/2022/03/18/LeetCode刷题/720.词典中最长的单词/","content":"\n# 720.词典中最长的单词\n\n## 题目描述\n\n返回words中最长的一个单词，该单词是由words词典中的其他单词逐步添加一个字母形成的\n\n返回答案中词典序最小的单词\n\n## 思路\n\n因为ans是words词典中其他单词逐步加一个字母形成的\n\n所以可以先按字典序排序，这样words就是形如```a,ab,b,bb,bbc```这样按词典序及长度排序的\n\n设置一个集合保存有用的单词\n\n遍历words，将长度为1的或者word的子串(0,length-1)在集合中，就将该word加入集合\n\n同时更新ans\n","categories":["LeetCode刷题"]},{"title":"33.搜索旋转排序数组","url":"/2021/11/09/LeetCode刷题/33.搜索旋转排序数组/","content":"\n# 33.搜索旋转排序数组\n\n## 思路\n\n给定一个数组，数组分为两段，每一段都是严格的单调增序列\n\n第一段的最小值大于第二段的最大值\n\n二分——原本想找到旋转点，使整个数组递增然后使用二分进行查找(错误)\n\n* 答案的写法\n\n        mid可能在第一个单调增区间也可能在第二个单调增区间\n\n        然后在每个单调增区间内使用二分\n\n        分成四种情况来讨论即可\n","categories":["LeetCode刷题"]},{"title":"32.最长有效括号","url":"/2021/11/08/LeetCode刷题/32.最长有效括号/","content":"\n# 32.最长有效括号\n\n我和答案的思路都是用栈，并且分段\n\n但是我分的真是太狗屎了，考虑记录长度，但是无法解决一些未匹配问题，当(左括号多时就不对了\n\n答案用栈记录了最后一个未匹配的)的下标\n\n对于遇到的每个‘(’，我们将它的下标放入栈中\n\n对于遇到的每个‘)’，我们先弹出栈顶元素表示匹配了当前右括号：\n\n如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」\n\n如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」\n\n\n如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。\n","categories":["LeetCode刷题"]},{"title":"31.下一个排列","url":"/2021/11/07/LeetCode刷题/31.下一个排列/","content":"\n# 31.下一个排列\n\n## 算法推导\n\n我们希望下一个数比当前数大，同时下一个数增加的幅度尽可能的小\n\n尽可能在靠右的低位进行交换\n\n从右向左找到第一个$a_i<a_{i+1}$,第i位右面的是递减的，那么也就是最大的排列\n\n如```3  654```,此时应该找右面最小的，但是比$a_i$大的一个数，让他和$a_i$互换位置\n\n因为如果是比$a_i$小的数，是比该排列小的排列，在这个排列前就已经出现过了\n\n互换完位置之后，将原$a_i$的位置后面的数按从小到大排列，就得到了最小排列\n","categories":["LeetCode刷题"]},{"title":"29.两数相除","url":"/2021/11/05/LeetCode刷题/29.两数相除/","content":"\n# 29.两数相除\n\n移位判断是否够减\n\n上下限的边界值处理\n\n## leetcode负数左移会报错\n\n{%asset_img 29.AddressSanitizer.png 左移报错 %}\n\n通过```unsigned int```强制类型转换可以跳过该限制，但是在某些情况需要将4字节内存再转换回int\n\n```dividend <= (int) (((unsigned int) divisor) << shift```\n\n如```dividend```是0，右侧是负数，但在```unsigned int```下为正数，导致判断失效\n\n## ++i和i++\n\n++i的速度会快一点，但是编译器会有优化，所以基本相同\n\n在自定义数据类型上++i的速度提升会更明显\n\n## 位运算\n\n最开始想用最底层的补码的位运算来实现，感觉时间并没有优化，int32位需要做32次循环\n","categories":["LeetCode刷题"]},{"title":"28.KMP算法","url":"/2021/11/04/LeetCode刷题/28.KMP算法/","content":"\n# 28.KMP算法\n\n## next数组\n\n求next数组时间复杂度O(n)匹配串长度\n\nPMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度\n\n如果是在j位失配，那么影响j指针回溯的位置的其实是第j−1位的PMT值，所以为了编程的方便，我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。\n\n在把PMT进行向右偏移时，第0位的值，将其设成了-1，为了编程的方便\n\n```C++\nvoid getNext(string needle, vector<int> &next) {\n    int m = needle.size();\n    next[0] = -1;\n    int i = 0, j = -1;\n    while (i < m) {\n        if (j == -1 || needle[i] == needle[j]) {\n            ++i;\n            ++j;\n            next[i] = j;\n        } else\n            j = next[j];\n    }\n}\n```\n\n求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。\n\n具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算\n\n## 匹配过程\n\n{%asset_img 28.KMP.jpg KMP %}\n\n从之前已匹配的位置继续匹配\n\n```C++\nint i = 0, j = 0;\nwhile (i < m && j < n) {\n    if (j == -1 || haystack[i] == needle[j]) {\n        i++;\n        j++;\n    } else {\n        j = next[j];\n    }\n}\nif (j == n) {\n    return i - j;\n} else {\n    return -1;\n}\n```\n\n当匹配不成功时，next数组不断回溯，直到回到next\\[0\\]\\(-1\\)\n\n匹配过程时间O(m)待匹配串长度\n","categories":["LeetCode刷题"]},{"title":"15.三数之和","url":"/2021/11/02/LeetCode刷题/15.三数之和/","content":"\n# 15.三数之和\n\n## 思路\n\n第一次提交317用例tle了，将nums的元素去重，只保留两个就可以\n\n然后用$n^2$的时间维护一个数组\n\n{%asset_img 15.table.jpg 数组 %}\n\ntable[i][j]中保存的是去重后的nums[i]+nums[j]的值\n\n然后用$n$的时间维护一个哈希表，将去重后的nums的值与下标对应\n\n遍历table，table的下标i，j与哈希表中的值分别是和为0的三个数的下标，将其排序插入到vector\n\n使用set保存vector，自动去重，返回即可\n\n**为什么我的时间复杂度也是$n^2$,甚至n的规模经过去重后已经变小了，性能还是不如官方给的题解好qaq**\n\n{%asset_img 15.submit.png submit %}\n\n## 在堆上开数组\n\n```C++\nint (*table)[3001] = new int[3001][3001];\n```\n\n## 集合\n\nset()\n\n无序\n\n集合里即使存放的是vector只要vector的内容vector[0]~vector[n]相同，也算作一个\n\n使用迭代器遍历\n\n```C++\nmap<int, int>::iterator it;\nfor (it = mp.begin(); it != mp.end(); it++) {\n\n}\n```\n","categories":["LeetCode刷题"]},{"title":"16.最接近的三数之和","url":"/2021/11/02/LeetCode刷题/16.最接近的三数之和/","content":"\n# 16.最接近的三数之和\n\n## lambda函数\n\nLambda表达式完整的声明格式如下：\n\n[caputure list] (params list) mutable exception-> return type {function body}\n\n各项具体含义如下\n\ncapture list：捕获外部变量列表\nparams list：形参列表\nmutable指示符：用来说用是否可以修改捕获的变量\nexception：异常设定\nreturn type：返回类型\nfunction body：函数体\n\n```C++\nauto update = [&](int cur) {\n    if (abs(cur - target) < abs(best - target)) {\n        best = cur;\n    }\n};\nupdate(sum);\n```\n\n## 双指针问题\n\n先排序，再用两个指针指向头和尾进行遍历\n","tags":["双指针"],"categories":["LeetCode刷题"]},{"title":"14.最长公共前缀","url":"/2021/11/01/LeetCode刷题/14.最长公共前缀/","content":"\n# 14.最长公共前缀\n\n## emplace_back和push_back的区别\n\nemplace_back和push_back都有往容器后面插入一个元素的作用\n\nemplace_back() 和 push_back() 的区别在于底层实现的机制不同\n\npush_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）\n\nemplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程\n\n## auto\n\n```C++\nvector<string> &strs\n\nfor (auto str : strs) {\n    如果传入的迭代参数类型为非引用时，做的是值拷贝，修改数据是无效的\n}\nfor (auto &str : strs) {\n    如果传递的是引用，则可以改变原有的值\n}\n\n```\n","categories":["LeetCode刷题"]},{"title":"5.最长回文子串","url":"/2021/10/26/LeetCode刷题/5.最长回文子串/","content":"\n# 5.最长回文子串\n\n## 思路(dp)\n\nstring.length = n\n\n$dp[i][j]=1$表示从第i个字符到第j个字符是回文子串\n\n{%asset_img 5.init.jpg 初始赋值 %}\n\n可以将蓝色框区域的dp赋值\n\n{%asset_img 5.ergodic.jpg 遍历 %}\n\n按箭头所示方向遍历\n\n在遍历的过程中记录最长回文子串\n\n```C++\nif (s[j] == s[i]) {\n    int temp = i - j + 1;\n    dp[j][i] = dp[j + 1][i - 1];\n    if (dp[j][i] == 1 && temp > max_len) {\n        left = j, right = i;\n        max_len = temp;\n    }\n}\n```\n\n## 栈与堆中变量的问题\n\n全局变量和static在静态存储区，其作用域是全局\n\n函数的局部变量在栈上分配\n\n堆——动态内存分配，编程者自行申请和释放空间。\n\n栈空间比较小，widows下1m或2m，堆空间比较大\n","categories":["LeetCode刷题"]},{"title":"8.字符串转换整数(atoi)","url":"/2021/10/26/LeetCode刷题/8.字符串转换整数/","content":"\n# 8.字符串转换整数(atoi)\n\n## 自动机\n\n虽然早就学过自动机理论，也进行过编程，但当时完全是用了一堆乱七八糟的if-else来实现的\n\n想起来上学期写编译的词法分析用到了自动机还用了一堆goto(捂脸.jpg)\n\n刚刚看了官方的题解，规范的自动机确实逻辑清晰，贴一下代码\n\n```C++\nclass Automaton {\n    string state = \"start\";\n    unordered_map<string, vector<string>> table = {\n        {\"start\", {\"start\", \"signed\", \"in_number\", \"end\"}},\n        {\"signed\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"in_number\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"end\", {\"end\", \"end\", \"end\", \"end\"}}\n    };\n\n    int get_col(char c) {\n        if (isspace(c)) return 0;\n        if (c == '+' or c == '-') return 1;\n        if (isdigit(c)) return 2;\n        return 3;\n    }\npublic:\n    int sign = 1;\n    long long ans = 0;\n\n    void get(char c) {\n        state = table[state][get_col(c)];\n        if (state == \"in_number\") {\n            ans = ans * 10 + c - '0';\n            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n        }\n        else if (state == \"signed\")\n            sign = c == '+' ? 1 : -1;\n    }\n};\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        Automaton automaton;\n        for (char c : str)\n            automaton.get(c);\n        return automaton.sign * automaton.ans;\n    }\n};\n```\n\n{%asset_img 8.automaton.png 自动机 %}\n","categories":["LeetCode刷题"]},{"title":"7.整数反转","url":"/2021/10/25/LeetCode刷题/7.整数反转/","content":"\n# 7.整数反转\n\n## 思路\n\n**只允许使用32位数！！**\n\n拿余数逐位进行遍历，模10取余数，乘10加余数\n\n$$ans*10+mod<INT\\_MAX$$\n\n在只使用32位数的情况下，显然在溢出真正发生的时候时没有办法正确判断的\n\n$INT\\_MAX=2^{31}-1=2147483647$\n\n$INT\\_MAX=INT\\_MAX/10+7$\n\n只有在整数位数和int_max相同并且最后一次运算时才有可能发生溢出，并且原始数据的int的范围限定了原始的最高位限定位1或2\n所以只要满足$ans<INT\\_max/10$即可\n\n负数懒得写了。\n\n## 负数除法（突然想到\n\n（/）除号的正负取舍和一般的算数一样，符号相同为正，相异为负\n\n（%）求余符号的正负取舍和被除数符号相同\n\n在C语言中，不要求余数为正\n\n但是在数学中，余数一定是正数\n","categories":["LeetCode刷题"]},{"title":"2.两数相加","url":"/2021/10/17/LeetCode刷题/2.两数相加/","content":"\n# 2.两数相加\n\n## 遇到的问题:LeetCode报错stack use after scope\n\n```C++\nListNode a(1);\n```\n\n这样写这个变量是个局部变量，作用域是当前这个函数，离开这个函数后这个变量的内存会被自动释放，在return返回该变量时会出现**指针悬空**。\n\n```C++\nListNode *a = new ListNode(1)\n```\n\n在堆中申请内存，即使离开这个函数，堆中申请的内存依然有效，在主函数中依然可以使用该指针。\n","categories":["LeetCode刷题"]},{"title":"3.无重复字符的最长子串","url":"/2021/10/17/LeetCode刷题/3.无重复字符的最长子串/","content":"\n# 3.无重复字符的最长子串\n\n思路:滑动窗口\n\n从字符串的第一个字符开始遍历，当遍历的字符在当前的最长子串中已经出现过的时候更新最长子串，从那个已存在的字符的下一位截取。如果当前字符不在当前最长子串时，更新最长子串的长度即可。\n\n设置变量来标志当前最长子串开始位置。\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        int alphabet[256] = {0};\n        int left = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int index = s[i];\n            //字母还未出现过，字母在left的左侧\n            if (alphabet[index] == 0 || alphabet[index] < left) {\n                ans = max(ans, i - left + 1);\n            } else {//字母在当前窗口内\n                left = alphabet[index];\n            }\n            alphabet[index] = i + 1;\n        }\n        return ans;\n    }\n};\n```\n","categories":["LeetCode刷题"]},{"title":"1.两数之和","url":"/2021/03/20/LeetCode刷题/1.两数之和/","content":"\n# 1.两数之和\n\n## 思路\n\n排序从两端遍历(O(nlogn)) ==> 哈希查找(O(n))\n\n## sort(algorithm)——2021-10-16\n\n适用范围:利用sort算法只能对序列容器进行排序(如vector，list，deque)\n\n```C++\nvoid sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n```\n\n1. 第一个参数first：是要排序的数组的起始地址\n2. 第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）\n3. 第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序\n\n### 对复杂结构进行排序\n\n从小到大排序:\n\n```C++\nbool cmpbyValue(pair<int, int> &lhs, pair<int, int> &rhs) {\n    return lhs.second < rhs.second;\n}\n```\n\n* 也可以通过重载来实现\n\n```C++\nstruct cmpbyValue {\n    bool operator()(const pair<int, int> &lhs, const pair<int, int> &rhs) { \n        return lhs.second < rhs.second; \n    }\n};\n```\n\n通过修改函数体内的内容,既可以实现对key的排序,也可以实现对value的排序。\n\n## unordered_map(哈希表)——2021.10.16\n\n哈希表的查找时间复杂度是O(1)\n在存储位置和Key之间建立一个确定的对应关系,存储位置=f(Key),通过随机方位，就可以在O(1)的时间内得到value的值\n\n1. 在存储时通过散列函数计算记录的散列地址\n2. 在查找时同样通过散列函数计算记录的散列地址\n\n### STL:unordered_map\n\n* 内部实现机理\nmap:map内部实现了一个红黑树,该结构具有自动排序的功能,因此map内部的所有元素都是有序的,红黑树的每一个节点都代表着map的一个元素,因此,对于map进行的查找,删除,添加等一系列的操作都相当于是对红黑树进行这样的操作,故红黑树的效率决定了map的效率。\n\nunordered_map:unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。\n\n* 查找:\n\n```C++\nauto it = hashtable.find(key);\nif (it != hashtable.end()) //查找成功\n```\n\n* 插入\n\n```C++\nhashtable[key]=value\n```\n","categories":["LeetCode刷题"]}]